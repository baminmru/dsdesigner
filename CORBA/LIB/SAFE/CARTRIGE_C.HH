#ifndef _cartrige_c_hh
#define _cartrige_c_hh

/**
 **************************************************************************
 *                                                                        *
 *                        -- DO NOT MODIFY --                             *
 *  This file is automatically generated by the VisiBroker IDL compiler.  *
 *  Generated code conforms to OMG's IDL-to-C++ 1.1 mapping as specified  *
 *  in OMG Document Number: 96-01-13                                      *
 *                                                                        *
 *  VisiBroker is copyrighted by Visigenic Software, Inc.                 *
 **************************************************************************
 */

#include "corba.h"

#include "vpre.h"
#ifndef OCTETS_H
#define OCTETS_H

class Octets;
typedef Octets *Octets_ptr;

class Octets {
private:
  CORBA::Octet *_contents;
  CORBA::ULong    _count;
  CORBA::ULong    _num_allocated;
  CORBA::Long     _ref_count;

  CORBA::Boolean  _release_flag;
public:

#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);

#endif

  static CORBA::Octet *allocbuf(CORBA::ULong _nelems);
  static void freebuf(CORBA::Octet *_data);
  Octets(CORBA::ULong _max=0);
  Octets(CORBA::ULong _max,
      CORBA::ULong _len,
      CORBA::Octet *_data,
      CORBA::Boolean _release=0);
  Octets(const Octets&);
  ~Octets();

  Octets& operator=(const Octets&);
  CORBA::ULong maximum() const { return _num_allocated; }
  void length(CORBA::ULong _len);
  CORBA::ULong length() const { return _count;}
  CORBA::Octet& operator[](CORBA::ULong _index) ;
  const CORBA::Octet& operator[](CORBA::ULong _index) const;

  friend VISostream& operator<<(VISostream&, const Octets&);
  inline friend VISostream& operator<<(VISostream& _strm, const Octets *_obj) {
    if ( _obj == (Octets*)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_obj;
    return _strm;
  }

  friend VISistream& operator>>(VISistream&, Octets&);
  inline friend VISistream& operator>>(VISistream& _strm, Octets_ptr & _obj) {
    _obj = new Octets;
    _strm >> *_obj;
    return _strm;
  }

  friend Ostream& operator<<(Ostream&, const Octets&);
  inline friend Istream& operator>>(Istream& _strm, Octets& _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  inline friend Istream& operator>>(Istream& _strm, Octets_ptr & _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  static Octets *_duplicate(Octets* _ptr) {
    if (_ptr) _ptr->_ref_count++;
    return _ptr;
  }

  static void _release(Octets *_ptr) {
    if (_ptr && ( --_ptr->_ref_count == 0) ) delete _ptr;
  }

};

class Octets_out;

class Octets_var {
  friend class Octets_out;
private:
  Octets *_ptr;

public:
  Octets_var() : _ptr((Octets *)NULL) {}
  Octets_var(Octets *_p) :_ptr(_p) {}
  Octets_var(const Octets_var& _var) :
    _ptr(Octets::_duplicate((Octets *)_var)){}
  ~Octets_var() { Octets::_release(_ptr); }

  Octets_var& operator=(Octets *_p) {
    Octets::_release(_ptr);
    _ptr = _p;
    return *this;
  }

  Octets_var& operator=(const Octets_var& _var) {
    Octets::_release(_ptr);
    _ptr = Octets::_duplicate((Octets *)_var);
    return *this;
  }

  Octets *operator->() { return _ptr; }
  CORBA::Octet& operator[](CORBA::ULong _index) {
    return _ptr->operator[](_index);
  }

  const CORBA::Octet& operator[](CORBA::ULong _index) const {
    return _ptr->operator[](_index);
  }

  operator Octets *() const { return _ptr; }
  operator const Octets& () const { return *_ptr; }
  operator Octets& () { return *_ptr; }

  const Octets& in() const { return *_ptr; }
  Octets& inout() { return *_ptr; }
  Octets_ptr & out();
  Octets* _retn() {
    Octets* _tmp_ptr;
    _tmp_ptr = _ptr;
    _ptr = (Octets *)NULL;
    return _tmp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const Octets_var& _var) {
    if ( _var._ptr == (Octets *)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend  VISistream& operator>>(
      VISistream& _strm,
      Octets_var& _var) {
    if ( _var._ptr == (Octets *)NULL )
      _var._ptr = new Octets;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class Octets_out {
private:
  Octets_ptr & _ptr;
  static Octets* _nil() { return (Octets*)NULL; }
  void operator=(const Octets_out&);
  void operator=(const Octets_var&);

public:
  Octets_out(const Octets_out& _o) : _ptr(_o._ptr) {}
  Octets_out(Octets_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  Octets_out(Octets_var& _v) : _ptr(_v._ptr) {
    Octets::_release(_ptr); _ptr = _nil();
  }
  Octets_out& operator=(Octets* _p) {
    _ptr = _p;
    return *this;
  }
  operator Octets_ptr &() { return _ptr; }
  Octets_ptr & ptr() { return _ptr; }
};
#endif

#ifndef _Cartrige_var_
#define _Cartrige_var_

class Cartrige;
typedef Cartrige* Cartrige_ptr;
typedef Cartrige_ptr CartrigeRef;

 VISistream& operator>>(VISistream&, Cartrige_ptr&);
 VISostream& operator<<(VISostream&, const Cartrige_ptr);

class Cartrige_out;
class Cartrige_var: public CORBA::_var {
  friend class Cartrige_out;

private:
  Cartrige_ptr _ptr;

public:
  void operator=(const Cartrige_var&_v) {
    if ( _ptr ) _release(_ptr);
    if ( _v._ptr )
      _ptr = _duplicate(_v._ptr);
    else
      _ptr = (Cartrige_ptr)NULL;
  }

  static Cartrige_ptr _duplicate(Cartrige_ptr);
  static void _release(Cartrige_ptr);

  Cartrige_var();
  Cartrige_var(Cartrige_ptr);
  Cartrige_var(const Cartrige_var&);
  ~Cartrige_var();
  Cartrige_var& operator=(Cartrige_ptr);
  operator Cartrige_ptr() const { return _ptr; }
  Cartrige_ptr operator->() const { return _ptr; }
  Cartrige_ptr in() const { return _ptr; }
  Cartrige_ptr& inout() { return _ptr; }
  Cartrige_ptr& out();
  Cartrige_ptr _retn() {
    Cartrige_ptr _tmp_ptr;
    _tmp_ptr = _ptr;
    _ptr = (Cartrige_ptr)NULL;
    return _tmp_ptr;
  }
  friend VISistream& operator>>(VISistream&, Cartrige_var&);
  friend VISostream& operator<<(VISostream&, const Cartrige_var&);
  friend Istream& operator>>(Istream&, Cartrige_var&);
  friend Ostream& operator<<(Ostream&, const Cartrige_var&);
};

class Cartrige_out {
private:
  Cartrige_ptr & _ptr;
  static Cartrige* _nil() { return (Cartrige*)NULL; }
  void operator=(const Cartrige_out&);
  void operator=(const Cartrige_var&);

public:
  Cartrige_out(const Cartrige_out& _o) : _ptr(_o._ptr) {}
  Cartrige_out(Cartrige_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  Cartrige_out(Cartrige_var& _v) : _ptr(_v._ptr) {
      Cartrige_var::_release(_ptr); _ptr = _nil();
  }
  ~Cartrige_out() {}
  Cartrige_out& operator=(Cartrige_ptr _p) {
      _ptr = _p; return *this;
  }
  operator Cartrige_ptr& () { return _ptr; }
  Cartrige_ptr& ptr() { return _ptr; }
  Cartrige_ptr operator->() { return _ptr; }
};


#endif

class Cartrige : public virtual CORBA_Object {
private:
  static const CORBA::TypeInfo _class_info;
  Cartrige(const Cartrige&){ ___root = this; }
  void operator=(const Cartrige&){}

protected:
  Cartrige_ptr ___root;
  void set_root(Cartrige_ptr root) {
    ___root = root;
  }
  
public:
  
  static  const CORBA::TypeInfo *_desc();
  virtual const CORBA::TypeInfo *_type_info() const;
  virtual void *_safe_narrow(const CORBA::TypeInfo& ) const;
  static CORBA::Object *_factory();

  Cartrige_ptr _this();
protected:

  Cartrige(const char *obj_name = NULL): CORBA_Object(obj_name, 1) { ___root = this; }
public:
  virtual ~Cartrige() {}

  static Cartrige_ptr _duplicate(Cartrige_ptr _obj) {
    if ( _obj ) _obj->_ref();
    return _obj;
  }
  static Cartrige_ptr _nil() { return (Cartrige_ptr)NULL; }
  static Cartrige_ptr _narrow(CORBA::Object *_obj);
  static Cartrige_ptr _clone(Cartrige_ptr _obj) {
    CORBA::Object_var _obj_var(__clone(_obj));
    
#if defined(_HPCC_BUG)
    return _narrow(_obj_var.operator CORBA::Object_ptr());
    
#else
    return _narrow(_obj_var);
    
#endif
  }

  static Cartrige_ptr _bind(
      const char *_object_name = NULL,
      const char *_host_name = NULL,
      const CORBA::BindOptions* _opt = NULL,
      CORBA::ORB_ptr _orb = NULL);

  virtual void DisConnect(
      CORBA::Long _Instance
      );

  virtual CORBA::Long OpenCursor(
      CORBA::Long _Instance,
      const char* _Query,
      const Octets& _Parameters
      );

  virtual void CloseInstance(
      CORBA::Long _Instance
      );

  virtual CORBA::Boolean IsConnected(
      CORBA::Long _Instance
      );

  virtual Octets* GetRowSet(
      CORBA::Long _Instance,
      const char* _Query,
      const Octets& _Parameters
      );

  virtual void Connect(
      CORBA::Long _Instance,
      const Octets& _Info
      );

  virtual Octets* GetConnectInfo(
      );

  virtual CORBA::Long NewInstance(
      );

  virtual Octets* GetCursorRow(
      CORBA::Long _Instance,
      CORBA::Long _Cursor
      );

  virtual CORBA::Boolean NoMoreRows(
      CORBA::Long _Instance,
      CORBA::Long _Cursor
      );

  virtual void CloseCursor(
      CORBA::Long _Instance,
      CORBA::Long _Cursor
      );

  virtual Octets* GetCursorHeared(
      CORBA::Long _Instance,
      CORBA::Long _Cursor
      );

  virtual void Exec(
      CORBA::Long _Instance,
      const char* _Query,
      const Octets& _Parameters
      );

  friend VISistream& operator>>(VISistream& _strm, Cartrige_ptr& _obj);
  friend VISostream& operator<<(VISostream& _strm, const Cartrige_ptr _obj);
  friend Ostream& operator<<(Ostream& _strm, const Cartrige_ptr _obj) {
    _strm << (CORBA::Object_ptr)_obj;
    return _strm;
  }

  friend Istream& operator>>(Istream& _strm, Cartrige_ptr& _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

};


#include "vpost.h"

#endif

