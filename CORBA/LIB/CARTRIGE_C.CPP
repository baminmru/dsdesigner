
/**
 **************************************************************************
 *                                                                        *
 *                        -- DO NOT MODIFY --                             *
 *  This file is automatically generated by the VisiBroker IDL compiler.  *
 *  Generated code conforms to OMG's IDL-to-C++ 1.1 mapping as specified  *
 *  in OMG Document Number: 96-01-13                                      *
 *                                                                        *
 *  VisiBroker is copyrighted by Visigenic Software, Inc.                 *
 **************************************************************************
 */

#include <corbapch.h>
#pragma hdrstop
#include "cartrige_c.hh"


#if defined(MSVCNEWDLL_BUG)
void *Octets::operator new(size_t ts) {
  return ::operator new(ts);
}

void Octets::operator delete(void *p) {
  ::operator delete(p);
}


#endif

CORBA::Octet* Octets::allocbuf(CORBA::ULong _nelems) {
  return new CORBA::Octet[_nelems];
}

void Octets::freebuf(CORBA::Octet *_data) {
  if (_data) delete[] _data;
}

Octets::Octets(CORBA::ULong _max) {
  _num_allocated = _max;
  _count = 0;
  if (_num_allocated > 0)
    _contents = allocbuf(_num_allocated);
  else
    _contents = (CORBA::Octet *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

Octets::Octets(
    CORBA::ULong _max,
    CORBA::ULong _len,
    CORBA::Octet *_data,
    CORBA::Boolean _release) {
  _num_allocated = _max;
  _count = _len;
  _contents = _data;
  _release_flag = _release;
  _ref_count = 1;
}

Octets::Octets(const Octets& _seq) {
  _num_allocated = _seq._num_allocated;
  _count = _seq._count;
  if (_num_allocated > 0) {
    _contents = allocbuf(_num_allocated);
    memcpy(_contents, _seq._contents, (size_t(_count) * sizeof(CORBA::Octet)));
  }
  else
    _contents = (CORBA::Octet *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

Octets::~Octets() {
  if (_release_flag) freebuf(_contents);
}

Octets& Octets::operator=(const Octets& _seq) {
  if (_count < _seq._count) {
    if (_num_allocated < _seq._count) {
      if (_release_flag)
        freebuf(_contents);
      else
        _release_flag = 1;
      _contents = allocbuf(_seq._num_allocated);
      _num_allocated = _seq._num_allocated;
    }
  }
  _count = _seq._count;
  memcpy(_contents, _seq._contents, (size_t(_count) * sizeof(CORBA::Octet)));
  return *this;
}

void Octets::length(CORBA::ULong _newlen) {
  if (_newlen > _num_allocated) {
    CORBA::Octet *temp = allocbuf(_newlen);
    memcpy(temp, _contents, (size_t(_count) * sizeof(CORBA::Octet)));
    if (_release_flag)
      freebuf(_contents);
    else
      _release_flag = 1;
    _num_allocated = _newlen;
    _contents = temp;
  }
  if (_newlen > _count)
    memset(&_contents[_count], 0, size_t(_newlen - _count) *
        sizeof(CORBA::Octet));
  _count = _newlen;
}

CORBA::Octet& Octets::operator[](CORBA::ULong _index) {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

const CORBA::Octet& Octets::operator[](CORBA::ULong _index) const {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

VISostream&  operator<<(VISostream& _strm, const Octets& _seq) {
  _strm << _seq._count;
  if (_seq._count > 0)
    _strm.put(_seq._contents, (unsigned int)_seq._count);
  return _strm;
}

VISistream& operator>>(VISistream& _strm,  Octets& _seq) {
  CORBA::ULong t_count;
  _strm >> t_count;
  if (t_count > 0 && ! _strm.is_available(t_count)) {
    throw CORBA::MARSHAL();
  }
  if (t_count > _seq._count) {
    if (_seq._num_allocated < t_count) {
      if (_seq._release_flag)
        Octets::freebuf(_seq._contents);
      else
        _seq._release_flag = 1;
      _seq._contents = Octets::allocbuf(t_count);
      _seq._num_allocated = t_count;
    }
  }
  _seq._count = t_count;
  if (_seq._count > 0)
    _strm.get(_seq._contents, (unsigned int)_seq._count);
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const Octets& _seq) {
  VISostream _ostrm(_strm);
  _ostrm << _seq;
  return _strm;
}


Octets_ptr & Octets_var::out() {
  Octets::_release(_ptr);
  _ptr = (Octets *)NULL;
  return _ptr;
}

Cartrige_ptr Cartrige_var:: _duplicate(Cartrige_ptr _p) { return Cartrige::_duplicate(_p); }
void Cartrige_var::_release(Cartrige_ptr _p) { CORBA::release(_p); }

Cartrige_var::Cartrige_var() : _ptr(Cartrige::_nil()) {}

Cartrige_var::Cartrige_var(Cartrige_ptr _p) : _ptr(_p) {}

Cartrige_var::Cartrige_var(const Cartrige_var& _var) :
   _ptr(Cartrige::_duplicate((Cartrige_ptr)_var)) {}

Cartrige_var::~Cartrige_var() { CORBA::release(_ptr); }

Cartrige_var& Cartrige_var::operator=(Cartrige_ptr _p) {
  CORBA::release(_ptr);
  _ptr = _p;
  return *this;
}


Cartrige_ptr& Cartrige_var::out() {
  CORBA::release(_ptr);
  _ptr = (Cartrige_ptr)NULL;
  return _ptr;
}

VISistream& operator>>(VISistream& _strm, Cartrige_var& _var) {
  _strm >> _var._ptr;
  return _strm;
}

VISostream& operator<<(VISostream& _strm, const Cartrige_var& _var) {
  _strm << _var._ptr;
  return _strm;
}

Istream& operator>>(Istream& _strm, Cartrige_var& _var) {
  VISistream _istrm(_strm);
  _istrm >> _var._ptr;
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const Cartrige_var& _var) {
  _strm << (CORBA::Object_ptr)_var._ptr;
  return _strm;
}

const CORBA::TypeInfo Cartrige::_class_info(
  "Cartrige",
  "IDL:Cartrige:1.0",
  NULL,
  &Cartrige::_factory,
  NULL, 0, 
  NULL, 0,
  CORBA::Object::_desc(),
  0);

VISistream& operator>>(VISistream& _strm, Cartrige_ptr& _obj) {
  CORBA::Object_var _var_obj(_obj);
  _var_obj = CORBA::Object::_read(_strm, Cartrige::_desc());
  _obj = Cartrige::_narrow(_var_obj);
  return _strm;
}

VISostream& operator<<(VISostream& _strm, const Cartrige_ptr _obj) {
  _strm << (CORBA_Object_ptr)_obj;
  return _strm;
}


const CORBA::TypeInfo *Cartrige::_desc() { return &_class_info; }

const CORBA::TypeInfo *Cartrige::_type_info() const { return &_class_info; }

void *Cartrige::_safe_narrow(const CORBA::TypeInfo& _info) const {
  if ( _info == _class_info) 
    return (void *)this;
  return CORBA_Object::_safe_narrow(_info);
}

CORBA::Object *Cartrige::_factory() {
  return new Cartrige;
}

Cartrige_ptr Cartrige::_this() {
  return Cartrige::_duplicate(___root);
}

Cartrige_ptr Cartrige::_narrow(CORBA::Object *_obj) {
  if ( _obj == CORBA::Object::_nil() )
    return Cartrige::_nil();
  else
    return Cartrige::_duplicate((Cartrige_ptr)_obj->_safe_narrow(_class_info));
}

Cartrige *Cartrige::_bind(
    const char *_object_name,
    const char *_host_name,
    const CORBA::BindOptions *_opt,
    CORBA::ORB_ptr _orb) {
  CORBA::Object_var _obj= CORBA::Object::_bind_to_object(
      "IDL:Cartrige:1.0", _object_name, _host_name, _opt, _orb);
  return Cartrige::_narrow(_obj);
}

void Cartrige::DisConnect(
    CORBA::Long _Instance
    ) {

  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "DisConnect",
        1,
        49430);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Instance;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
}

CORBA::Long Cartrige::OpenCursor(
    CORBA::Long _Instance,
    const char* _Query,
    const Octets& _Parameters
    ) {

  CORBA::Long _ret = (CORBA::Long)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "OpenCursor",
        1,
        51904);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Instance;
    _ostrm << _Query;
    _ostrm << _Parameters;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

void Cartrige::CloseInstance(
    CORBA::Long _Instance
    ) {

  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "CloseInstance",
        1,
        416563);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Instance;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
}

CORBA::Boolean Cartrige::IsConnected(
    CORBA::Long _Instance
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "IsConnected",
        1,
        107766);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Instance;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

Octets* Cartrige::GetRowSet(
    CORBA::Long _Instance,
    const char* _Query,
    const Octets& _Parameters
    ) {

  Octets* _ret = (Octets*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetRowSet",
        1,
        26234);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Instance;
    _ostrm << _Query;
    _ostrm << _Parameters;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

void Cartrige::Connect(
    CORBA::Long _Instance,
    const Octets& _Info
    ) {

  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "Connect",
        1,
        6550);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Instance;
    _ostrm << _Info;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
}

Octets* Cartrige::GetConnectInfo(
    ) {

  Octets* _ret = (Octets*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetConnectInfo",
        1,
        821811);
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Long Cartrige::NewInstance(
    ) {

  CORBA::Long _ret = (CORBA::Long)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "NewInstance",
        1,
        110899);
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

Octets* Cartrige::GetCursorRow(
    CORBA::Long _Instance,
    CORBA::Long _Cursor
    ) {

  Octets* _ret = (Octets*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetCursorRow",
        1,
        207841);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Instance;
    _ostrm << _Cursor;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean Cartrige::NoMoreRows(
    CORBA::Long _Instance,
    CORBA::Long _Cursor
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "NoMoreRows",
        1,
        50657);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Instance;
    _ostrm << _Cursor;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

void Cartrige::CloseCursor(
    CORBA::Long _Instance,
    CORBA::Long _Cursor
    ) {

  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "CloseCursor",
        1,
        103936);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Instance;
    _ostrm << _Cursor;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
}

Octets* Cartrige::GetCursorHeared(
    CORBA::Long _Instance,
    CORBA::Long _Cursor
    ) {

  Octets* _ret = (Octets*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetCursorHeared",
        1,
        1662270);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Instance;
    _ostrm << _Cursor;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

void Cartrige::Exec(
    CORBA::Long _Instance,
    const char* _Query,
    const Octets& _Parameters
    ) {

  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "Exec",
        1,
        865);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Instance;
    _ostrm << _Query;
    _ostrm << _Parameters;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
}

