#ifndef _admin_c_hh
#define _admin_c_hh

/**
 **************************************************************************
 *                                                                        *
 *                        -- DO NOT MODIFY --                             *
 *  This file is automatically generated by the VisiBroker IDL compiler.  *
 *  Generated code conforms to OMG's IDL-to-C++ 1.1 mapping as specified  *
 *  in OMG Document Number: 96-01-13                                      *
 *                                                                        *
 *  VisiBroker is copyrighted by Visigenic Software, Inc.                 *
 **************************************************************************
 */

#include "corba.h"

#include "vpre.h"

class sList;
typedef sList *sList_ptr;

class sList {
private:
  char* *_buffer;
  CORBA::ULong    _count;
  CORBA::ULong    _num_allocated;
  CORBA::Long     _ref_count;

  CORBA::Boolean  _rel_flag;
  void release_on_copy(CORBA::Boolean _val) { _rel_flag = _val; }
  CORBA::Boolean release_on_copy() const { return _rel_flag; }

public:
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

  static char* *allocbuf(CORBA::ULong _nelems);
  static void freebuf(char* *_data);
  static void freebuf_elems(char* *_data, CORBA::ULong _nelem);
  
  class Sequence_string {
    friend class sList;

  private:
    CORBA::Boolean  _rel_flag;
    char** _ptr;
    void release() {if (_rel_flag) CORBA::string_free(*_ptr);}
    Sequence_string& operator=(const Sequence_string& ) {
      return *this;
    }

  public:
    Sequence_string(char* *_p, CORBA::Boolean _rel) :
        _ptr(_p), _rel_flag(_rel) {}

    Sequence_string(const Sequence_string& _seq) {
      _ptr = _seq._ptr; _rel_flag = _seq._rel_flag;
    }

    ~Sequence_string() {}

    Sequence_string& operator=(char* _p) {
      if ( *_ptr != _p) {
        release();
        *_ptr = _p;
      }
      return *this;
    }

    Sequence_string& operator=(const char* _p) {
      if ( *_ptr != _p) {
        release();
        *_ptr = CORBA::string_alloc(strlen(_p));
        strcpy(*_ptr, _p);
      }

      return *this;
    }

    operator const char *() const { return *_ptr; }
    operator char *() { return *_ptr; }
    char& operator[](CORBA::ULong _idx) {return *_ptr[_idx];}
    char operator[](CORBA::ULong _idx) const {return *_ptr[_idx];}
  };

  sList(CORBA::ULong _max=0);
  sList(CORBA::ULong _max,
      CORBA::ULong _len,
      char* *_data,
      CORBA::Boolean _rel=0);
  sList(const sList&);
  ~sList();

  sList& operator=(const sList&);
  CORBA::ULong maximum() const { return _num_allocated; }
  void length(CORBA::ULong _len);
  CORBA::ULong length() const { return _count;}

  Sequence_string operator[](CORBA::ULong _idx) {
    if (_idx >= _count)
      throw CORBA::BAD_PARAM();
    return Sequence_string(&_buffer[_idx], _rel_flag);
  }

  const char * operator[](CORBA::ULong _idx) const {
    if (_idx >= _count)
      throw CORBA::BAD_PARAM();
    return _buffer[_idx];
  }

  friend VISostream& operator<<(VISostream&, const sList&);
  inline friend VISostream& operator<<(VISostream& _strm, const sList *_obj) {
    if ( _obj == (sList*)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_obj;
    return _strm;
  }

  friend VISistream& operator>>(VISistream&, sList&);
  inline friend VISistream& operator>>(VISistream& _strm, sList_ptr & _obj) {
    _obj = new sList;
    _strm >> *_obj;
    return _strm;
  }

  friend Ostream& operator<<(Ostream&, const sList&);
  inline friend Istream& operator>>(Istream& _strm, sList& _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  inline friend Istream& operator>>(Istream& _strm, sList_ptr & _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  static sList *_duplicate(sList* _p) {
    if (_p) _p->_ref_count++;
    return _p;
  }

  static void _release(sList *_p) {
    if (_p && ( --_p->_ref_count == 0) ) delete _p;
  }

};

class sList_out;

class sList_var {
  friend class sList_out;
private:
  sList *_ptr;

public:
  sList_var() { _ptr = (sList *)NULL; }
  sList_var(sList *_p) {
    _ptr = _p;
  }

  sList_var(const sList_var& _var) {
    _ptr = sList::_duplicate((sList *)_var);
  }

  ~sList_var() { sList::_release(_ptr); }

  sList_var& operator=(sList *_p) {
    sList::_release(_ptr);
    _ptr = _p;
    return *this;
  }

  sList_var& operator=(const sList_var& _var) {
    sList::_release(_ptr);
    _ptr = sList::_duplicate((sList *)_var);
    return *this;
  }

  sList *operator->() { return _ptr; }
  sList::Sequence_string operator[](CORBA::ULong _idx) {
    return _ptr->operator[](_idx);
  }

  const char *operator[](CORBA::ULong _idx) const {
    return _ptr->operator[](_idx);
  }

  operator sList *() const { return _ptr; }
  operator const sList& () const { return *_ptr; }
  operator sList& () { return *_ptr; }

  const sList& in() const { return *_ptr; }
  sList& inout() { return *_ptr; }
  sList_ptr & out();
  sList* _retn() {
    sList* _tmp_ptr;
    _tmp_ptr = _ptr;
    _ptr = (sList *)NULL;
    return _tmp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const sList_var& _var) {
    if ( _var._ptr == (sList *)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend  VISistream& operator>>(
      VISistream& _strm,
      sList_var& _var) {
    if ( _var._ptr == (sList *)NULL )
      _var._ptr = new sList;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class sList_out {
private:
  sList_ptr & _ptr;
  static sList* _nil() { return (sList*)NULL; }
  void operator=(const sList_out&);
  void operator=(const sList_var&);

public:
  sList_out(const sList_out& _o) : _ptr(_o._ptr) {}
  sList_out(sList_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  sList_out(sList_var& _v) : _ptr(_v._ptr) {
    sList::_release(_ptr); _ptr = _nil();
  }
  sList_out& operator=(sList* _p) {
    _ptr = _p;
    return *this;
  }
  operator sList_ptr &() { return _ptr; }
  sList_ptr & ptr() { return _ptr; }
};

class seqOctets;
typedef seqOctets *seqOctets_ptr;

class seqOctets {
private:
  CORBA::Octet *_contents;
  CORBA::ULong    _count;
  CORBA::ULong    _num_allocated;
  CORBA::Long     _ref_count;

  CORBA::Boolean  _release_flag;
public:
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

  static CORBA::Octet *allocbuf(CORBA::ULong _nelems);
  static void freebuf(CORBA::Octet *_data);
  seqOctets(CORBA::ULong _max=0);
  seqOctets(CORBA::ULong _max,
      CORBA::ULong _len,
      CORBA::Octet *_data,
      CORBA::Boolean _release=0);
  seqOctets(const seqOctets&);
  ~seqOctets();

  seqOctets& operator=(const seqOctets&);
  CORBA::ULong maximum() const { return _num_allocated; }
  void length(CORBA::ULong _len);
  CORBA::ULong length() const { return _count;}
  CORBA::Octet& operator[](CORBA::ULong _index) ;
  const CORBA::Octet& operator[](CORBA::ULong _index) const;

  friend VISostream& operator<<(VISostream&, const seqOctets&);
  inline friend VISostream& operator<<(VISostream& _strm, const seqOctets *_obj) {
    if ( _obj == (seqOctets*)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_obj;
    return _strm;
  }

  friend VISistream& operator>>(VISistream&, seqOctets&);
  inline friend VISistream& operator>>(VISistream& _strm, seqOctets_ptr & _obj) {
    _obj = new seqOctets;
    _strm >> *_obj;
    return _strm;
  }

  friend Ostream& operator<<(Ostream&, const seqOctets&);
  inline friend Istream& operator>>(Istream& _strm, seqOctets& _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  inline friend Istream& operator>>(Istream& _strm, seqOctets_ptr & _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  static seqOctets *_duplicate(seqOctets* _ptr) {
    if (_ptr) _ptr->_ref_count++;
    return _ptr;
  }

  static void _release(seqOctets *_ptr) {
    if (_ptr && ( --_ptr->_ref_count == 0) ) delete _ptr;
  }

};

class seqOctets_out;

class seqOctets_var {
  friend class seqOctets_out;
private:
  seqOctets *_ptr;

public:
  seqOctets_var() : _ptr((seqOctets *)NULL) {}
  seqOctets_var(seqOctets *_p) :_ptr(_p) {}
  seqOctets_var(const seqOctets_var& _var) :
    _ptr(seqOctets::_duplicate((seqOctets *)_var)){}
  ~seqOctets_var() { seqOctets::_release(_ptr); }

  seqOctets_var& operator=(seqOctets *_p) {
    seqOctets::_release(_ptr);
    _ptr = _p;
    return *this;
  }

  seqOctets_var& operator=(const seqOctets_var& _var) {
    seqOctets::_release(_ptr);
    _ptr = seqOctets::_duplicate((seqOctets *)_var);
    return *this;
  }

  seqOctets *operator->() { return _ptr; }
  CORBA::Octet& operator[](CORBA::ULong _index) {
    return _ptr->operator[](_index);
  }

  const CORBA::Octet& operator[](CORBA::ULong _index) const {
    return _ptr->operator[](_index);
  }

  operator seqOctets *() const { return _ptr; }
  operator const seqOctets& () const { return *_ptr; }
  operator seqOctets& () { return *_ptr; }

  const seqOctets& in() const { return *_ptr; }
  seqOctets& inout() { return *_ptr; }
  seqOctets_ptr & out();
  seqOctets* _retn() {
    seqOctets* _tmp_ptr;
    _tmp_ptr = _ptr;
    _ptr = (seqOctets *)NULL;
    return _tmp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const seqOctets_var& _var) {
    if ( _var._ptr == (seqOctets *)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend  VISistream& operator>>(
      VISistream& _strm,
      seqOctets_var& _var) {
    if ( _var._ptr == (seqOctets *)NULL )
      _var._ptr = new seqOctets;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class seqOctets_out {
private:
  seqOctets_ptr & _ptr;
  static seqOctets* _nil() { return (seqOctets*)NULL; }
  void operator=(const seqOctets_out&);
  void operator=(const seqOctets_var&);

public:
  seqOctets_out(const seqOctets_out& _o) : _ptr(_o._ptr) {}
  seqOctets_out(seqOctets_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  seqOctets_out(seqOctets_var& _v) : _ptr(_v._ptr) {
    seqOctets::_release(_ptr); _ptr = _nil();
  }
  seqOctets_out& operator=(seqOctets* _p) {
    _ptr = _p;
    return *this;
  }
  operator seqOctets_ptr &() { return _ptr; }
  seqOctets_ptr & ptr() { return _ptr; }
};

struct TwiceString {
  CORBA::String_var Name1;
  CORBA::String_var Name2;
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

};

VISostream& operator<<(VISostream&, const TwiceString& );
VISistream& operator>>(VISistream&, TwiceString& );

typedef TwiceString* TwiceString_ptr;

inline VISistream& operator>>(VISistream& _strm, TwiceString_ptr & _obj) {
  _obj = new TwiceString;
  _strm >> *_obj;
  return _strm;
}

Ostream& operator<<(Ostream&, const TwiceString& );
inline Istream& operator>>(Istream& _strm, TwiceString& _obj) {
  VISistream _istrm(_strm);
  _istrm >> _obj;
  return _strm;
}

inline Istream& operator>>(Istream& _strm, TwiceString_ptr & _obj) {
  _obj = new TwiceString;
  _strm >> *_obj;
  return _strm;
}

class TwiceString_out;

class TwiceString_var {
  friend class TwiceString_out;
private:
  TwiceString* _ptr;

public:
  TwiceString_var() { _ptr = (TwiceString*)NULL;}
  TwiceString_var(TwiceString *_p) { _ptr = _p; }
  TwiceString_var(const TwiceString_var& _var) {
    if (_var._ptr)
      _ptr = new TwiceString(*_var._ptr);
    else
      _ptr = (TwiceString *)NULL;
  }

  ~TwiceString_var() {
    if (_ptr != (TwiceString *)NULL) delete _ptr;
  }

  TwiceString_var& operator=(TwiceString *_p) {
    if (_ptr != (TwiceString *)NULL) delete _ptr;
    _ptr = _p;
    return *this;
  }

  TwiceString_var& operator=(const TwiceString_var& _var) {
    if (_ptr != (TwiceString *)NULL) delete _ptr;
    if (_var._ptr)
      _ptr = new TwiceString(*_var._ptr);
    else
      _ptr = (TwiceString *)NULL;
    return *this;
  }

  TwiceString *operator->() { return _ptr; }
  operator TwiceString *() const { return _ptr; }
  operator TwiceString& () { return *_ptr; }
  const TwiceString& in() const { return *_ptr; }
  TwiceString& inout() { return *_ptr; }
  TwiceString_ptr & out();
  TwiceString* _retn() {
    TwiceString* temp_ptr;
    temp_ptr = _ptr;
    _ptr = (TwiceString *)NULL;
    return temp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const TwiceString_var& _var) {
    if (_var._ptr == (TwiceString *)NULL)
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend VISistream& operator>>(
      VISistream& _strm,
      TwiceString_var& _var) {
    if ( !_var._ptr )
      _var._ptr = new TwiceString;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class TwiceString_out {
private:
  TwiceString_ptr & _ptr;
  static TwiceString* _nil() { return (TwiceString*)NULL; }
  void operator=(const TwiceString_out&);
  void operator=(const TwiceString_var&);

public:
  TwiceString_out(const TwiceString_out& _o) : _ptr(_o._ptr) {}
  TwiceString_out(TwiceString_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  TwiceString_out(TwiceString_var& _v) : _ptr(_v._ptr) {
    delete _ptr; _ptr = _nil();
  }
  TwiceString_out& operator=(TwiceString* _p) {
    _ptr = _p;
    return *this;
  }
  operator TwiceString_ptr &() { return _ptr; }
  TwiceString_ptr & ptr() { return _ptr; }
  TwiceString* operator->() { return _ptr; }
};

class seqTwiceStrings;
typedef seqTwiceStrings *seqTwiceStrings_ptr;

class seqTwiceStrings {
private:
  TwiceString *_contents;
  CORBA::ULong    _count;
  CORBA::ULong    _num_allocated;
  CORBA::Long     _ref_count;

  CORBA::Boolean  _release_flag;
public:
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

  static TwiceString *allocbuf(CORBA::ULong _nelems);
  static void freebuf(TwiceString *_data);
  seqTwiceStrings(CORBA::ULong _max=0);
  seqTwiceStrings(CORBA::ULong _max,
      CORBA::ULong _len,
      TwiceString *_data,
      CORBA::Boolean _release=0);
  seqTwiceStrings(const seqTwiceStrings&);
  ~seqTwiceStrings();

  seqTwiceStrings& operator=(const seqTwiceStrings&);
  CORBA::ULong maximum() const { return _num_allocated; }
  void length(CORBA::ULong _len);
  CORBA::ULong length() const { return _count;}
  TwiceString& operator[](CORBA::ULong _index) ;
  const TwiceString& operator[](CORBA::ULong _index) const;

  friend VISostream& operator<<(VISostream&, const seqTwiceStrings&);
  inline friend VISostream& operator<<(VISostream& _strm, const seqTwiceStrings *_obj) {
    if ( _obj == (seqTwiceStrings*)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_obj;
    return _strm;
  }

  friend VISistream& operator>>(VISistream&, seqTwiceStrings&);
  inline friend VISistream& operator>>(VISistream& _strm, seqTwiceStrings_ptr & _obj) {
    _obj = new seqTwiceStrings;
    _strm >> *_obj;
    return _strm;
  }

  friend Ostream& operator<<(Ostream&, const seqTwiceStrings&);
  inline friend Istream& operator>>(Istream& _strm, seqTwiceStrings& _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  inline friend Istream& operator>>(Istream& _strm, seqTwiceStrings_ptr & _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  static seqTwiceStrings *_duplicate(seqTwiceStrings* _ptr) {
    if (_ptr) _ptr->_ref_count++;
    return _ptr;
  }

  static void _release(seqTwiceStrings *_ptr) {
    if (_ptr && ( --_ptr->_ref_count == 0) ) delete _ptr;
  }

};

class seqTwiceStrings_out;

class seqTwiceStrings_var {
  friend class seqTwiceStrings_out;
private:
  seqTwiceStrings *_ptr;

public:
  seqTwiceStrings_var() : _ptr((seqTwiceStrings *)NULL) {}
  seqTwiceStrings_var(seqTwiceStrings *_p) :_ptr(_p) {}
  seqTwiceStrings_var(const seqTwiceStrings_var& _var) :
    _ptr(seqTwiceStrings::_duplicate((seqTwiceStrings *)_var)){}
  ~seqTwiceStrings_var() { seqTwiceStrings::_release(_ptr); }

  seqTwiceStrings_var& operator=(seqTwiceStrings *_p) {
    seqTwiceStrings::_release(_ptr);
    _ptr = _p;
    return *this;
  }

  seqTwiceStrings_var& operator=(const seqTwiceStrings_var& _var) {
    seqTwiceStrings::_release(_ptr);
    _ptr = seqTwiceStrings::_duplicate((seqTwiceStrings *)_var);
    return *this;
  }

  seqTwiceStrings *operator->() { return _ptr; }
  TwiceString& operator[](CORBA::ULong _index) {
    return _ptr->operator[](_index);
  }

  const TwiceString& operator[](CORBA::ULong _index) const {
    return _ptr->operator[](_index);
  }

  operator seqTwiceStrings *() const { return _ptr; }
  operator const seqTwiceStrings& () const { return *_ptr; }
  operator seqTwiceStrings& () { return *_ptr; }

  const seqTwiceStrings& in() const { return *_ptr; }
  seqTwiceStrings& inout() { return *_ptr; }
  seqTwiceStrings_ptr & out();
  seqTwiceStrings* _retn() {
    seqTwiceStrings* _tmp_ptr;
    _tmp_ptr = _ptr;
    _ptr = (seqTwiceStrings *)NULL;
    return _tmp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const seqTwiceStrings_var& _var) {
    if ( _var._ptr == (seqTwiceStrings *)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend  VISistream& operator>>(
      VISistream& _strm,
      seqTwiceStrings_var& _var) {
    if ( _var._ptr == (seqTwiceStrings *)NULL )
      _var._ptr = new seqTwiceStrings;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class seqTwiceStrings_out {
private:
  seqTwiceStrings_ptr & _ptr;
  static seqTwiceStrings* _nil() { return (seqTwiceStrings*)NULL; }
  void operator=(const seqTwiceStrings_out&);
  void operator=(const seqTwiceStrings_var&);

public:
  seqTwiceStrings_out(const seqTwiceStrings_out& _o) : _ptr(_o._ptr) {}
  seqTwiceStrings_out(seqTwiceStrings_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  seqTwiceStrings_out(seqTwiceStrings_var& _v) : _ptr(_v._ptr) {
    seqTwiceStrings::_release(_ptr); _ptr = _nil();
  }
  seqTwiceStrings_out& operator=(seqTwiceStrings* _p) {
    _ptr = _p;
    return *this;
  }
  operator seqTwiceStrings_ptr &() { return _ptr; }
  seqTwiceStrings_ptr & ptr() { return _ptr; }
};

enum DbType {
  dbtNumeric,
  dbtString,
  dbtDate,
  dbtBinary
};

inline VISostream& operator<<(VISostream& _strm, DbType _enum_type) {
  _strm << (CORBA::ULong)_enum_type;
   return _strm;
}

inline VISistream& operator>>(VISistream& _strm, DbType& _enum_type) {
  CORBA::ULong _temp;
  _strm >> _temp;
  if (_temp >= 4) {
    throw CORBA::BAD_PARAM();
  }
  _enum_type = (DbType)_temp;
  return _strm;
}

inline Ostream& operator<<(Ostream& _strm, DbType _enum_type) {
  _strm << (CORBA::ULong)_enum_type;
  return _strm;
}

inline Istream& operator>>(Istream& _strm, DbType& _enum_type) {
  CORBA::ULong _temp;
  _strm >> _temp;
  _enum_type = (DbType)_temp;
  return _strm;
}

struct SetDate {
  CORBA::Long Y;
  CORBA::Short M;
  CORBA::Short D;
  CORBA::Short H;
  CORBA::Short Mi;
  CORBA::Short S;
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

};

VISostream& operator<<(VISostream&, const SetDate& );
VISistream& operator>>(VISistream&, SetDate& );

typedef SetDate* SetDate_ptr;

inline VISistream& operator>>(VISistream& _strm, SetDate_ptr & _obj) {
  _obj = new SetDate;
  _strm >> *_obj;
  return _strm;
}

Ostream& operator<<(Ostream&, const SetDate& );
inline Istream& operator>>(Istream& _strm, SetDate& _obj) {
  VISistream _istrm(_strm);
  _istrm >> _obj;
  return _strm;
}

inline Istream& operator>>(Istream& _strm, SetDate_ptr & _obj) {
  _obj = new SetDate;
  _strm >> *_obj;
  return _strm;
}

class SetDate_var {
private:
  SetDate* _ptr;

public:
  SetDate_var() { _ptr = (SetDate*)NULL;}
  SetDate_var(SetDate *_p) { _ptr = _p; }
  SetDate_var(const SetDate_var& _var) {
    if (_var._ptr)
      _ptr = new SetDate(*_var._ptr);
    else
      _ptr = (SetDate *)NULL;
  }

  ~SetDate_var() {
    if (_ptr != (SetDate *)NULL) delete _ptr;
  }

  SetDate_var& operator=(SetDate *_p) {
    if (_ptr != (SetDate *)NULL) delete _ptr;
    _ptr = _p;
    return *this;
  }

  SetDate_var& operator=(const SetDate_var& _var) {
    if (_ptr != (SetDate *)NULL) delete _ptr;
    if (_var._ptr)
      _ptr = new SetDate(*_var._ptr);
    else
      _ptr = (SetDate *)NULL;
    return *this;
  }

  SetDate *operator->() { return _ptr; }
  operator SetDate *() const { return _ptr; }
  operator SetDate& () { return *_ptr; }
  const SetDate& in() const { return *_ptr; }
  SetDate& inout() { return *_ptr; }
  SetDate& out() { return *_ptr; }
  SetDate _retn() { return *_ptr; }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const SetDate_var& _var) {
    if (_var._ptr == (SetDate *)NULL)
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend VISistream& operator>>(
      VISistream& _strm,
      SetDate_var& _var) {
    if ( !_var._ptr )
      _var._ptr = new SetDate;
    _strm >> *_var._ptr;
    return _strm;
  }

};

struct SetDataField {
  CORBA::Boolean IsNull;
  DbType FType;
  CORBA::Double vNumeric;
  CORBA::String_var vString;
  seqOctets vBinary;
  SetDate vDate;
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

};

VISostream& operator<<(VISostream&, const SetDataField& );
VISistream& operator>>(VISistream&, SetDataField& );

typedef SetDataField* SetDataField_ptr;

inline VISistream& operator>>(VISistream& _strm, SetDataField_ptr & _obj) {
  _obj = new SetDataField;
  _strm >> *_obj;
  return _strm;
}

Ostream& operator<<(Ostream&, const SetDataField& );
inline Istream& operator>>(Istream& _strm, SetDataField& _obj) {
  VISistream _istrm(_strm);
  _istrm >> _obj;
  return _strm;
}

inline Istream& operator>>(Istream& _strm, SetDataField_ptr & _obj) {
  _obj = new SetDataField;
  _strm >> *_obj;
  return _strm;
}

class SetDataField_out;

class SetDataField_var {
  friend class SetDataField_out;
private:
  SetDataField* _ptr;

public:
  SetDataField_var() { _ptr = (SetDataField*)NULL;}
  SetDataField_var(SetDataField *_p) { _ptr = _p; }
  SetDataField_var(const SetDataField_var& _var) {
    if (_var._ptr)
      _ptr = new SetDataField(*_var._ptr);
    else
      _ptr = (SetDataField *)NULL;
  }

  ~SetDataField_var() {
    if (_ptr != (SetDataField *)NULL) delete _ptr;
  }

  SetDataField_var& operator=(SetDataField *_p) {
    if (_ptr != (SetDataField *)NULL) delete _ptr;
    _ptr = _p;
    return *this;
  }

  SetDataField_var& operator=(const SetDataField_var& _var) {
    if (_ptr != (SetDataField *)NULL) delete _ptr;
    if (_var._ptr)
      _ptr = new SetDataField(*_var._ptr);
    else
      _ptr = (SetDataField *)NULL;
    return *this;
  }

  SetDataField *operator->() { return _ptr; }
  operator SetDataField *() const { return _ptr; }
  operator SetDataField& () { return *_ptr; }
  const SetDataField& in() const { return *_ptr; }
  SetDataField& inout() { return *_ptr; }
  SetDataField_ptr & out();
  SetDataField* _retn() {
    SetDataField* temp_ptr;
    temp_ptr = _ptr;
    _ptr = (SetDataField *)NULL;
    return temp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const SetDataField_var& _var) {
    if (_var._ptr == (SetDataField *)NULL)
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend VISistream& operator>>(
      VISistream& _strm,
      SetDataField_var& _var) {
    if ( !_var._ptr )
      _var._ptr = new SetDataField;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class SetDataField_out {
private:
  SetDataField_ptr & _ptr;
  static SetDataField* _nil() { return (SetDataField*)NULL; }
  void operator=(const SetDataField_out&);
  void operator=(const SetDataField_var&);

public:
  SetDataField_out(const SetDataField_out& _o) : _ptr(_o._ptr) {}
  SetDataField_out(SetDataField_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  SetDataField_out(SetDataField_var& _v) : _ptr(_v._ptr) {
    delete _ptr; _ptr = _nil();
  }
  SetDataField_out& operator=(SetDataField* _p) {
    _ptr = _p;
    return *this;
  }
  operator SetDataField_ptr &() { return _ptr; }
  SetDataField_ptr & ptr() { return _ptr; }
  SetDataField* operator->() { return _ptr; }
};

struct Param {
  CORBA::String_var Name;
  SetDataField Value;
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

};

VISostream& operator<<(VISostream&, const Param& );
VISistream& operator>>(VISistream&, Param& );

typedef Param* Param_ptr;

inline VISistream& operator>>(VISistream& _strm, Param_ptr & _obj) {
  _obj = new Param;
  _strm >> *_obj;
  return _strm;
}

Ostream& operator<<(Ostream&, const Param& );
inline Istream& operator>>(Istream& _strm, Param& _obj) {
  VISistream _istrm(_strm);
  _istrm >> _obj;
  return _strm;
}

inline Istream& operator>>(Istream& _strm, Param_ptr & _obj) {
  _obj = new Param;
  _strm >> *_obj;
  return _strm;
}

class Param_out;

class Param_var {
  friend class Param_out;
private:
  Param* _ptr;

public:
  Param_var() { _ptr = (Param*)NULL;}
  Param_var(Param *_p) { _ptr = _p; }
  Param_var(const Param_var& _var) {
    if (_var._ptr)
      _ptr = new Param(*_var._ptr);
    else
      _ptr = (Param *)NULL;
  }

  ~Param_var() {
    if (_ptr != (Param *)NULL) delete _ptr;
  }

  Param_var& operator=(Param *_p) {
    if (_ptr != (Param *)NULL) delete _ptr;
    _ptr = _p;
    return *this;
  }

  Param_var& operator=(const Param_var& _var) {
    if (_ptr != (Param *)NULL) delete _ptr;
    if (_var._ptr)
      _ptr = new Param(*_var._ptr);
    else
      _ptr = (Param *)NULL;
    return *this;
  }

  Param *operator->() { return _ptr; }
  operator Param *() const { return _ptr; }
  operator Param& () { return *_ptr; }
  const Param& in() const { return *_ptr; }
  Param& inout() { return *_ptr; }
  Param_ptr & out();
  Param* _retn() {
    Param* temp_ptr;
    temp_ptr = _ptr;
    _ptr = (Param *)NULL;
    return temp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const Param_var& _var) {
    if (_var._ptr == (Param *)NULL)
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend VISistream& operator>>(
      VISistream& _strm,
      Param_var& _var) {
    if ( !_var._ptr )
      _var._ptr = new Param;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class Param_out {
private:
  Param_ptr & _ptr;
  static Param* _nil() { return (Param*)NULL; }
  void operator=(const Param_out&);
  void operator=(const Param_var&);

public:
  Param_out(const Param_out& _o) : _ptr(_o._ptr) {}
  Param_out(Param_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  Param_out(Param_var& _v) : _ptr(_v._ptr) {
    delete _ptr; _ptr = _nil();
  }
  Param_out& operator=(Param* _p) {
    _ptr = _p;
    return *this;
  }
  operator Param_ptr &() { return _ptr; }
  Param_ptr & ptr() { return _ptr; }
  Param* operator->() { return _ptr; }
};

class seqParams;
typedef seqParams *seqParams_ptr;

class seqParams {
private:
  Param *_contents;
  CORBA::ULong    _count;
  CORBA::ULong    _num_allocated;
  CORBA::Long     _ref_count;

  CORBA::Boolean  _release_flag;
public:
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

  static Param *allocbuf(CORBA::ULong _nelems);
  static void freebuf(Param *_data);
  seqParams(CORBA::ULong _max=0);
  seqParams(CORBA::ULong _max,
      CORBA::ULong _len,
      Param *_data,
      CORBA::Boolean _release=0);
  seqParams(const seqParams&);
  ~seqParams();

  seqParams& operator=(const seqParams&);
  CORBA::ULong maximum() const { return _num_allocated; }
  void length(CORBA::ULong _len);
  CORBA::ULong length() const { return _count;}
  Param& operator[](CORBA::ULong _index) ;
  const Param& operator[](CORBA::ULong _index) const;

  friend VISostream& operator<<(VISostream&, const seqParams&);
  inline friend VISostream& operator<<(VISostream& _strm, const seqParams *_obj) {
    if ( _obj == (seqParams*)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_obj;
    return _strm;
  }

  friend VISistream& operator>>(VISistream&, seqParams&);
  inline friend VISistream& operator>>(VISistream& _strm, seqParams_ptr & _obj) {
    _obj = new seqParams;
    _strm >> *_obj;
    return _strm;
  }

  friend Ostream& operator<<(Ostream&, const seqParams&);
  inline friend Istream& operator>>(Istream& _strm, seqParams& _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  inline friend Istream& operator>>(Istream& _strm, seqParams_ptr & _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  static seqParams *_duplicate(seqParams* _ptr) {
    if (_ptr) _ptr->_ref_count++;
    return _ptr;
  }

  static void _release(seqParams *_ptr) {
    if (_ptr && ( --_ptr->_ref_count == 0) ) delete _ptr;
  }

};

class seqParams_out;

class seqParams_var {
  friend class seqParams_out;
private:
  seqParams *_ptr;

public:
  seqParams_var() : _ptr((seqParams *)NULL) {}
  seqParams_var(seqParams *_p) :_ptr(_p) {}
  seqParams_var(const seqParams_var& _var) :
    _ptr(seqParams::_duplicate((seqParams *)_var)){}
  ~seqParams_var() { seqParams::_release(_ptr); }

  seqParams_var& operator=(seqParams *_p) {
    seqParams::_release(_ptr);
    _ptr = _p;
    return *this;
  }

  seqParams_var& operator=(const seqParams_var& _var) {
    seqParams::_release(_ptr);
    _ptr = seqParams::_duplicate((seqParams *)_var);
    return *this;
  }

  seqParams *operator->() { return _ptr; }
  Param& operator[](CORBA::ULong _index) {
    return _ptr->operator[](_index);
  }

  const Param& operator[](CORBA::ULong _index) const {
    return _ptr->operator[](_index);
  }

  operator seqParams *() const { return _ptr; }
  operator const seqParams& () const { return *_ptr; }
  operator seqParams& () { return *_ptr; }

  const seqParams& in() const { return *_ptr; }
  seqParams& inout() { return *_ptr; }
  seqParams_ptr & out();
  seqParams* _retn() {
    seqParams* _tmp_ptr;
    _tmp_ptr = _ptr;
    _ptr = (seqParams *)NULL;
    return _tmp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const seqParams_var& _var) {
    if ( _var._ptr == (seqParams *)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend  VISistream& operator>>(
      VISistream& _strm,
      seqParams_var& _var) {
    if ( _var._ptr == (seqParams *)NULL )
      _var._ptr = new seqParams;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class seqParams_out {
private:
  seqParams_ptr & _ptr;
  static seqParams* _nil() { return (seqParams*)NULL; }
  void operator=(const seqParams_out&);
  void operator=(const seqParams_var&);

public:
  seqParams_out(const seqParams_out& _o) : _ptr(_o._ptr) {}
  seqParams_out(seqParams_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  seqParams_out(seqParams_var& _v) : _ptr(_v._ptr) {
    seqParams::_release(_ptr); _ptr = _nil();
  }
  seqParams_out& operator=(seqParams* _p) {
    _ptr = _p;
    return *this;
  }
  operator seqParams_ptr &() { return _ptr; }
  seqParams_ptr & ptr() { return _ptr; }
};

struct CartrigeParam {
  CORBA::String_var Name;
  CORBA::Boolean AllowNull;
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

};

VISostream& operator<<(VISostream&, const CartrigeParam& );
VISistream& operator>>(VISistream&, CartrigeParam& );

typedef CartrigeParam* CartrigeParam_ptr;

inline VISistream& operator>>(VISistream& _strm, CartrigeParam_ptr & _obj) {
  _obj = new CartrigeParam;
  _strm >> *_obj;
  return _strm;
}

Ostream& operator<<(Ostream&, const CartrigeParam& );
inline Istream& operator>>(Istream& _strm, CartrigeParam& _obj) {
  VISistream _istrm(_strm);
  _istrm >> _obj;
  return _strm;
}

inline Istream& operator>>(Istream& _strm, CartrigeParam_ptr & _obj) {
  _obj = new CartrigeParam;
  _strm >> *_obj;
  return _strm;
}

class CartrigeParam_out;

class CartrigeParam_var {
  friend class CartrigeParam_out;
private:
  CartrigeParam* _ptr;

public:
  CartrigeParam_var() { _ptr = (CartrigeParam*)NULL;}
  CartrigeParam_var(CartrigeParam *_p) { _ptr = _p; }
  CartrigeParam_var(const CartrigeParam_var& _var) {
    if (_var._ptr)
      _ptr = new CartrigeParam(*_var._ptr);
    else
      _ptr = (CartrigeParam *)NULL;
  }

  ~CartrigeParam_var() {
    if (_ptr != (CartrigeParam *)NULL) delete _ptr;
  }

  CartrigeParam_var& operator=(CartrigeParam *_p) {
    if (_ptr != (CartrigeParam *)NULL) delete _ptr;
    _ptr = _p;
    return *this;
  }

  CartrigeParam_var& operator=(const CartrigeParam_var& _var) {
    if (_ptr != (CartrigeParam *)NULL) delete _ptr;
    if (_var._ptr)
      _ptr = new CartrigeParam(*_var._ptr);
    else
      _ptr = (CartrigeParam *)NULL;
    return *this;
  }

  CartrigeParam *operator->() { return _ptr; }
  operator CartrigeParam *() const { return _ptr; }
  operator CartrigeParam& () { return *_ptr; }
  const CartrigeParam& in() const { return *_ptr; }
  CartrigeParam& inout() { return *_ptr; }
  CartrigeParam_ptr & out();
  CartrigeParam* _retn() {
    CartrigeParam* temp_ptr;
    temp_ptr = _ptr;
    _ptr = (CartrigeParam *)NULL;
    return temp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const CartrigeParam_var& _var) {
    if (_var._ptr == (CartrigeParam *)NULL)
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend VISistream& operator>>(
      VISistream& _strm,
      CartrigeParam_var& _var) {
    if ( !_var._ptr )
      _var._ptr = new CartrigeParam;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class CartrigeParam_out {
private:
  CartrigeParam_ptr & _ptr;
  static CartrigeParam* _nil() { return (CartrigeParam*)NULL; }
  void operator=(const CartrigeParam_out&);
  void operator=(const CartrigeParam_var&);

public:
  CartrigeParam_out(const CartrigeParam_out& _o) : _ptr(_o._ptr) {}
  CartrigeParam_out(CartrigeParam_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  CartrigeParam_out(CartrigeParam_var& _v) : _ptr(_v._ptr) {
    delete _ptr; _ptr = _nil();
  }
  CartrigeParam_out& operator=(CartrigeParam* _p) {
    _ptr = _p;
    return *this;
  }
  operator CartrigeParam_ptr &() { return _ptr; }
  CartrigeParam_ptr & ptr() { return _ptr; }
  CartrigeParam* operator->() { return _ptr; }
};

class seqCartrigeParams;
typedef seqCartrigeParams *seqCartrigeParams_ptr;

class seqCartrigeParams {
private:
  CartrigeParam *_contents;
  CORBA::ULong    _count;
  CORBA::ULong    _num_allocated;
  CORBA::Long     _ref_count;

  CORBA::Boolean  _release_flag;
public:
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

  static CartrigeParam *allocbuf(CORBA::ULong _nelems);
  static void freebuf(CartrigeParam *_data);
  seqCartrigeParams(CORBA::ULong _max=0);
  seqCartrigeParams(CORBA::ULong _max,
      CORBA::ULong _len,
      CartrigeParam *_data,
      CORBA::Boolean _release=0);
  seqCartrigeParams(const seqCartrigeParams&);
  ~seqCartrigeParams();

  seqCartrigeParams& operator=(const seqCartrigeParams&);
  CORBA::ULong maximum() const { return _num_allocated; }
  void length(CORBA::ULong _len);
  CORBA::ULong length() const { return _count;}
  CartrigeParam& operator[](CORBA::ULong _index) ;
  const CartrigeParam& operator[](CORBA::ULong _index) const;

  friend VISostream& operator<<(VISostream&, const seqCartrigeParams&);
  inline friend VISostream& operator<<(VISostream& _strm, const seqCartrigeParams *_obj) {
    if ( _obj == (seqCartrigeParams*)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_obj;
    return _strm;
  }

  friend VISistream& operator>>(VISistream&, seqCartrigeParams&);
  inline friend VISistream& operator>>(VISistream& _strm, seqCartrigeParams_ptr & _obj) {
    _obj = new seqCartrigeParams;
    _strm >> *_obj;
    return _strm;
  }

  friend Ostream& operator<<(Ostream&, const seqCartrigeParams&);
  inline friend Istream& operator>>(Istream& _strm, seqCartrigeParams& _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  inline friend Istream& operator>>(Istream& _strm, seqCartrigeParams_ptr & _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  static seqCartrigeParams *_duplicate(seqCartrigeParams* _ptr) {
    if (_ptr) _ptr->_ref_count++;
    return _ptr;
  }

  static void _release(seqCartrigeParams *_ptr) {
    if (_ptr && ( --_ptr->_ref_count == 0) ) delete _ptr;
  }

};

class seqCartrigeParams_out;

class seqCartrigeParams_var {
  friend class seqCartrigeParams_out;
private:
  seqCartrigeParams *_ptr;

public:
  seqCartrigeParams_var() : _ptr((seqCartrigeParams *)NULL) {}
  seqCartrigeParams_var(seqCartrigeParams *_p) :_ptr(_p) {}
  seqCartrigeParams_var(const seqCartrigeParams_var& _var) :
    _ptr(seqCartrigeParams::_duplicate((seqCartrigeParams *)_var)){}
  ~seqCartrigeParams_var() { seqCartrigeParams::_release(_ptr); }

  seqCartrigeParams_var& operator=(seqCartrigeParams *_p) {
    seqCartrigeParams::_release(_ptr);
    _ptr = _p;
    return *this;
  }

  seqCartrigeParams_var& operator=(const seqCartrigeParams_var& _var) {
    seqCartrigeParams::_release(_ptr);
    _ptr = seqCartrigeParams::_duplicate((seqCartrigeParams *)_var);
    return *this;
  }

  seqCartrigeParams *operator->() { return _ptr; }
  CartrigeParam& operator[](CORBA::ULong _index) {
    return _ptr->operator[](_index);
  }

  const CartrigeParam& operator[](CORBA::ULong _index) const {
    return _ptr->operator[](_index);
  }

  operator seqCartrigeParams *() const { return _ptr; }
  operator const seqCartrigeParams& () const { return *_ptr; }
  operator seqCartrigeParams& () { return *_ptr; }

  const seqCartrigeParams& in() const { return *_ptr; }
  seqCartrigeParams& inout() { return *_ptr; }
  seqCartrigeParams_ptr & out();
  seqCartrigeParams* _retn() {
    seqCartrigeParams* _tmp_ptr;
    _tmp_ptr = _ptr;
    _ptr = (seqCartrigeParams *)NULL;
    return _tmp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const seqCartrigeParams_var& _var) {
    if ( _var._ptr == (seqCartrigeParams *)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend  VISistream& operator>>(
      VISistream& _strm,
      seqCartrigeParams_var& _var) {
    if ( _var._ptr == (seqCartrigeParams *)NULL )
      _var._ptr = new seqCartrigeParams;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class seqCartrigeParams_out {
private:
  seqCartrigeParams_ptr & _ptr;
  static seqCartrigeParams* _nil() { return (seqCartrigeParams*)NULL; }
  void operator=(const seqCartrigeParams_out&);
  void operator=(const seqCartrigeParams_var&);

public:
  seqCartrigeParams_out(const seqCartrigeParams_out& _o) : _ptr(_o._ptr) {}
  seqCartrigeParams_out(seqCartrigeParams_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  seqCartrigeParams_out(seqCartrigeParams_var& _v) : _ptr(_v._ptr) {
    seqCartrigeParams::_release(_ptr); _ptr = _nil();
  }
  seqCartrigeParams_out& operator=(seqCartrigeParams* _p) {
    _ptr = _p;
    return *this;
  }
  operator seqCartrigeParams_ptr &() { return _ptr; }
  seqCartrigeParams_ptr & ptr() { return _ptr; }
};

struct SetHeaderField {
  CORBA::String_var Name;
  DbType FType;
  CORBA::Boolean AllowNull;
  CORBA::Long MaxSize;
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

};

VISostream& operator<<(VISostream&, const SetHeaderField& );
VISistream& operator>>(VISistream&, SetHeaderField& );

typedef SetHeaderField* SetHeaderField_ptr;

inline VISistream& operator>>(VISistream& _strm, SetHeaderField_ptr & _obj) {
  _obj = new SetHeaderField;
  _strm >> *_obj;
  return _strm;
}

Ostream& operator<<(Ostream&, const SetHeaderField& );
inline Istream& operator>>(Istream& _strm, SetHeaderField& _obj) {
  VISistream _istrm(_strm);
  _istrm >> _obj;
  return _strm;
}

inline Istream& operator>>(Istream& _strm, SetHeaderField_ptr & _obj) {
  _obj = new SetHeaderField;
  _strm >> *_obj;
  return _strm;
}

class SetHeaderField_out;

class SetHeaderField_var {
  friend class SetHeaderField_out;
private:
  SetHeaderField* _ptr;

public:
  SetHeaderField_var() { _ptr = (SetHeaderField*)NULL;}
  SetHeaderField_var(SetHeaderField *_p) { _ptr = _p; }
  SetHeaderField_var(const SetHeaderField_var& _var) {
    if (_var._ptr)
      _ptr = new SetHeaderField(*_var._ptr);
    else
      _ptr = (SetHeaderField *)NULL;
  }

  ~SetHeaderField_var() {
    if (_ptr != (SetHeaderField *)NULL) delete _ptr;
  }

  SetHeaderField_var& operator=(SetHeaderField *_p) {
    if (_ptr != (SetHeaderField *)NULL) delete _ptr;
    _ptr = _p;
    return *this;
  }

  SetHeaderField_var& operator=(const SetHeaderField_var& _var) {
    if (_ptr != (SetHeaderField *)NULL) delete _ptr;
    if (_var._ptr)
      _ptr = new SetHeaderField(*_var._ptr);
    else
      _ptr = (SetHeaderField *)NULL;
    return *this;
  }

  SetHeaderField *operator->() { return _ptr; }
  operator SetHeaderField *() const { return _ptr; }
  operator SetHeaderField& () { return *_ptr; }
  const SetHeaderField& in() const { return *_ptr; }
  SetHeaderField& inout() { return *_ptr; }
  SetHeaderField_ptr & out();
  SetHeaderField* _retn() {
    SetHeaderField* temp_ptr;
    temp_ptr = _ptr;
    _ptr = (SetHeaderField *)NULL;
    return temp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const SetHeaderField_var& _var) {
    if (_var._ptr == (SetHeaderField *)NULL)
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend VISistream& operator>>(
      VISistream& _strm,
      SetHeaderField_var& _var) {
    if ( !_var._ptr )
      _var._ptr = new SetHeaderField;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class SetHeaderField_out {
private:
  SetHeaderField_ptr & _ptr;
  static SetHeaderField* _nil() { return (SetHeaderField*)NULL; }
  void operator=(const SetHeaderField_out&);
  void operator=(const SetHeaderField_var&);

public:
  SetHeaderField_out(const SetHeaderField_out& _o) : _ptr(_o._ptr) {}
  SetHeaderField_out(SetHeaderField_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  SetHeaderField_out(SetHeaderField_var& _v) : _ptr(_v._ptr) {
    delete _ptr; _ptr = _nil();
  }
  SetHeaderField_out& operator=(SetHeaderField* _p) {
    _ptr = _p;
    return *this;
  }
  operator SetHeaderField_ptr &() { return _ptr; }
  SetHeaderField_ptr & ptr() { return _ptr; }
  SetHeaderField* operator->() { return _ptr; }
};

class seqSetHeader;
typedef seqSetHeader *seqSetHeader_ptr;

class seqSetHeader {
private:
  SetHeaderField *_contents;
  CORBA::ULong    _count;
  CORBA::ULong    _num_allocated;
  CORBA::Long     _ref_count;

  CORBA::Boolean  _release_flag;
public:
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

  static SetHeaderField *allocbuf(CORBA::ULong _nelems);
  static void freebuf(SetHeaderField *_data);
  seqSetHeader(CORBA::ULong _max=0);
  seqSetHeader(CORBA::ULong _max,
      CORBA::ULong _len,
      SetHeaderField *_data,
      CORBA::Boolean _release=0);
  seqSetHeader(const seqSetHeader&);
  ~seqSetHeader();

  seqSetHeader& operator=(const seqSetHeader&);
  CORBA::ULong maximum() const { return _num_allocated; }
  void length(CORBA::ULong _len);
  CORBA::ULong length() const { return _count;}
  SetHeaderField& operator[](CORBA::ULong _index) ;
  const SetHeaderField& operator[](CORBA::ULong _index) const;

  friend VISostream& operator<<(VISostream&, const seqSetHeader&);
  inline friend VISostream& operator<<(VISostream& _strm, const seqSetHeader *_obj) {
    if ( _obj == (seqSetHeader*)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_obj;
    return _strm;
  }

  friend VISistream& operator>>(VISistream&, seqSetHeader&);
  inline friend VISistream& operator>>(VISistream& _strm, seqSetHeader_ptr & _obj) {
    _obj = new seqSetHeader;
    _strm >> *_obj;
    return _strm;
  }

  friend Ostream& operator<<(Ostream&, const seqSetHeader&);
  inline friend Istream& operator>>(Istream& _strm, seqSetHeader& _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  inline friend Istream& operator>>(Istream& _strm, seqSetHeader_ptr & _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  static seqSetHeader *_duplicate(seqSetHeader* _ptr) {
    if (_ptr) _ptr->_ref_count++;
    return _ptr;
  }

  static void _release(seqSetHeader *_ptr) {
    if (_ptr && ( --_ptr->_ref_count == 0) ) delete _ptr;
  }

};

class seqSetHeader_out;

class seqSetHeader_var {
  friend class seqSetHeader_out;
private:
  seqSetHeader *_ptr;

public:
  seqSetHeader_var() : _ptr((seqSetHeader *)NULL) {}
  seqSetHeader_var(seqSetHeader *_p) :_ptr(_p) {}
  seqSetHeader_var(const seqSetHeader_var& _var) :
    _ptr(seqSetHeader::_duplicate((seqSetHeader *)_var)){}
  ~seqSetHeader_var() { seqSetHeader::_release(_ptr); }

  seqSetHeader_var& operator=(seqSetHeader *_p) {
    seqSetHeader::_release(_ptr);
    _ptr = _p;
    return *this;
  }

  seqSetHeader_var& operator=(const seqSetHeader_var& _var) {
    seqSetHeader::_release(_ptr);
    _ptr = seqSetHeader::_duplicate((seqSetHeader *)_var);
    return *this;
  }

  seqSetHeader *operator->() { return _ptr; }
  SetHeaderField& operator[](CORBA::ULong _index) {
    return _ptr->operator[](_index);
  }

  const SetHeaderField& operator[](CORBA::ULong _index) const {
    return _ptr->operator[](_index);
  }

  operator seqSetHeader *() const { return _ptr; }
  operator const seqSetHeader& () const { return *_ptr; }
  operator seqSetHeader& () { return *_ptr; }

  const seqSetHeader& in() const { return *_ptr; }
  seqSetHeader& inout() { return *_ptr; }
  seqSetHeader_ptr & out();
  seqSetHeader* _retn() {
    seqSetHeader* _tmp_ptr;
    _tmp_ptr = _ptr;
    _ptr = (seqSetHeader *)NULL;
    return _tmp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const seqSetHeader_var& _var) {
    if ( _var._ptr == (seqSetHeader *)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend  VISistream& operator>>(
      VISistream& _strm,
      seqSetHeader_var& _var) {
    if ( _var._ptr == (seqSetHeader *)NULL )
      _var._ptr = new seqSetHeader;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class seqSetHeader_out {
private:
  seqSetHeader_ptr & _ptr;
  static seqSetHeader* _nil() { return (seqSetHeader*)NULL; }
  void operator=(const seqSetHeader_out&);
  void operator=(const seqSetHeader_var&);

public:
  seqSetHeader_out(const seqSetHeader_out& _o) : _ptr(_o._ptr) {}
  seqSetHeader_out(seqSetHeader_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  seqSetHeader_out(seqSetHeader_var& _v) : _ptr(_v._ptr) {
    seqSetHeader::_release(_ptr); _ptr = _nil();
  }
  seqSetHeader_out& operator=(seqSetHeader* _p) {
    _ptr = _p;
    return *this;
  }
  operator seqSetHeader_ptr &() { return _ptr; }
  seqSetHeader_ptr & ptr() { return _ptr; }
};

class seqSetRow;
typedef seqSetRow *seqSetRow_ptr;

class seqSetRow {
private:
  SetDataField *_contents;
  CORBA::ULong    _count;
  CORBA::ULong    _num_allocated;
  CORBA::Long     _ref_count;

  CORBA::Boolean  _release_flag;
public:
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

  static SetDataField *allocbuf(CORBA::ULong _nelems);
  static void freebuf(SetDataField *_data);
  seqSetRow(CORBA::ULong _max=0);
  seqSetRow(CORBA::ULong _max,
      CORBA::ULong _len,
      SetDataField *_data,
      CORBA::Boolean _release=0);
  seqSetRow(const seqSetRow&);
  ~seqSetRow();

  seqSetRow& operator=(const seqSetRow&);
  CORBA::ULong maximum() const { return _num_allocated; }
  void length(CORBA::ULong _len);
  CORBA::ULong length() const { return _count;}
  SetDataField& operator[](CORBA::ULong _index) ;
  const SetDataField& operator[](CORBA::ULong _index) const;

  friend VISostream& operator<<(VISostream&, const seqSetRow&);
  inline friend VISostream& operator<<(VISostream& _strm, const seqSetRow *_obj) {
    if ( _obj == (seqSetRow*)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_obj;
    return _strm;
  }

  friend VISistream& operator>>(VISistream&, seqSetRow&);
  inline friend VISistream& operator>>(VISistream& _strm, seqSetRow_ptr & _obj) {
    _obj = new seqSetRow;
    _strm >> *_obj;
    return _strm;
  }

  friend Ostream& operator<<(Ostream&, const seqSetRow&);
  inline friend Istream& operator>>(Istream& _strm, seqSetRow& _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  inline friend Istream& operator>>(Istream& _strm, seqSetRow_ptr & _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  static seqSetRow *_duplicate(seqSetRow* _ptr) {
    if (_ptr) _ptr->_ref_count++;
    return _ptr;
  }

  static void _release(seqSetRow *_ptr) {
    if (_ptr && ( --_ptr->_ref_count == 0) ) delete _ptr;
  }

};

class seqSetRow_out;

class seqSetRow_var {
  friend class seqSetRow_out;
private:
  seqSetRow *_ptr;

public:
  seqSetRow_var() : _ptr((seqSetRow *)NULL) {}
  seqSetRow_var(seqSetRow *_p) :_ptr(_p) {}
  seqSetRow_var(const seqSetRow_var& _var) :
    _ptr(seqSetRow::_duplicate((seqSetRow *)_var)){}
  ~seqSetRow_var() { seqSetRow::_release(_ptr); }

  seqSetRow_var& operator=(seqSetRow *_p) {
    seqSetRow::_release(_ptr);
    _ptr = _p;
    return *this;
  }

  seqSetRow_var& operator=(const seqSetRow_var& _var) {
    seqSetRow::_release(_ptr);
    _ptr = seqSetRow::_duplicate((seqSetRow *)_var);
    return *this;
  }

  seqSetRow *operator->() { return _ptr; }
  SetDataField& operator[](CORBA::ULong _index) {
    return _ptr->operator[](_index);
  }

  const SetDataField& operator[](CORBA::ULong _index) const {
    return _ptr->operator[](_index);
  }

  operator seqSetRow *() const { return _ptr; }
  operator const seqSetRow& () const { return *_ptr; }
  operator seqSetRow& () { return *_ptr; }

  const seqSetRow& in() const { return *_ptr; }
  seqSetRow& inout() { return *_ptr; }
  seqSetRow_ptr & out();
  seqSetRow* _retn() {
    seqSetRow* _tmp_ptr;
    _tmp_ptr = _ptr;
    _ptr = (seqSetRow *)NULL;
    return _tmp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const seqSetRow_var& _var) {
    if ( _var._ptr == (seqSetRow *)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend  VISistream& operator>>(
      VISistream& _strm,
      seqSetRow_var& _var) {
    if ( _var._ptr == (seqSetRow *)NULL )
      _var._ptr = new seqSetRow;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class seqSetRow_out {
private:
  seqSetRow_ptr & _ptr;
  static seqSetRow* _nil() { return (seqSetRow*)NULL; }
  void operator=(const seqSetRow_out&);
  void operator=(const seqSetRow_var&);

public:
  seqSetRow_out(const seqSetRow_out& _o) : _ptr(_o._ptr) {}
  seqSetRow_out(seqSetRow_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  seqSetRow_out(seqSetRow_var& _v) : _ptr(_v._ptr) {
    seqSetRow::_release(_ptr); _ptr = _nil();
  }
  seqSetRow_out& operator=(seqSetRow* _p) {
    _ptr = _p;
    return *this;
  }
  operator seqSetRow_ptr &() { return _ptr; }
  seqSetRow_ptr & ptr() { return _ptr; }
};

class seqSetRows;
typedef seqSetRows *seqSetRows_ptr;

class seqSetRows {
private:
  seqSetRow *_contents;
  CORBA::ULong    _count;
  CORBA::ULong    _num_allocated;
  CORBA::Long     _ref_count;

  CORBA::Boolean  _release_flag;
public:
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

  static seqSetRow *allocbuf(CORBA::ULong _nelems);
  static void freebuf(seqSetRow *_data);
  seqSetRows(CORBA::ULong _max=0);
  seqSetRows(CORBA::ULong _max,
      CORBA::ULong _len,
      seqSetRow *_data,
      CORBA::Boolean _release=0);
  seqSetRows(const seqSetRows&);
  ~seqSetRows();

  seqSetRows& operator=(const seqSetRows&);
  CORBA::ULong maximum() const { return _num_allocated; }
  void length(CORBA::ULong _len);
  CORBA::ULong length() const { return _count;}
  seqSetRow& operator[](CORBA::ULong _index) ;
  const seqSetRow& operator[](CORBA::ULong _index) const;

  friend VISostream& operator<<(VISostream&, const seqSetRows&);
  inline friend VISostream& operator<<(VISostream& _strm, const seqSetRows *_obj) {
    if ( _obj == (seqSetRows*)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_obj;
    return _strm;
  }

  friend VISistream& operator>>(VISistream&, seqSetRows&);
  inline friend VISistream& operator>>(VISistream& _strm, seqSetRows_ptr & _obj) {
    _obj = new seqSetRows;
    _strm >> *_obj;
    return _strm;
  }

  friend Ostream& operator<<(Ostream&, const seqSetRows&);
  inline friend Istream& operator>>(Istream& _strm, seqSetRows& _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  inline friend Istream& operator>>(Istream& _strm, seqSetRows_ptr & _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  static seqSetRows *_duplicate(seqSetRows* _ptr) {
    if (_ptr) _ptr->_ref_count++;
    return _ptr;
  }

  static void _release(seqSetRows *_ptr) {
    if (_ptr && ( --_ptr->_ref_count == 0) ) delete _ptr;
  }

};

class seqSetRows_out;

class seqSetRows_var {
  friend class seqSetRows_out;
private:
  seqSetRows *_ptr;

public:
  seqSetRows_var() : _ptr((seqSetRows *)NULL) {}
  seqSetRows_var(seqSetRows *_p) :_ptr(_p) {}
  seqSetRows_var(const seqSetRows_var& _var) :
    _ptr(seqSetRows::_duplicate((seqSetRows *)_var)){}
  ~seqSetRows_var() { seqSetRows::_release(_ptr); }

  seqSetRows_var& operator=(seqSetRows *_p) {
    seqSetRows::_release(_ptr);
    _ptr = _p;
    return *this;
  }

  seqSetRows_var& operator=(const seqSetRows_var& _var) {
    seqSetRows::_release(_ptr);
    _ptr = seqSetRows::_duplicate((seqSetRows *)_var);
    return *this;
  }

  seqSetRows *operator->() { return _ptr; }
  seqSetRow& operator[](CORBA::ULong _index) {
    return _ptr->operator[](_index);
  }

  const seqSetRow& operator[](CORBA::ULong _index) const {
    return _ptr->operator[](_index);
  }

  operator seqSetRows *() const { return _ptr; }
  operator const seqSetRows& () const { return *_ptr; }
  operator seqSetRows& () { return *_ptr; }

  const seqSetRows& in() const { return *_ptr; }
  seqSetRows& inout() { return *_ptr; }
  seqSetRows_ptr & out();
  seqSetRows* _retn() {
    seqSetRows* _tmp_ptr;
    _tmp_ptr = _ptr;
    _ptr = (seqSetRows *)NULL;
    return _tmp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const seqSetRows_var& _var) {
    if ( _var._ptr == (seqSetRows *)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend  VISistream& operator>>(
      VISistream& _strm,
      seqSetRows_var& _var) {
    if ( _var._ptr == (seqSetRows *)NULL )
      _var._ptr = new seqSetRows;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class seqSetRows_out {
private:
  seqSetRows_ptr & _ptr;
  static seqSetRows* _nil() { return (seqSetRows*)NULL; }
  void operator=(const seqSetRows_out&);
  void operator=(const seqSetRows_var&);

public:
  seqSetRows_out(const seqSetRows_out& _o) : _ptr(_o._ptr) {}
  seqSetRows_out(seqSetRows_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  seqSetRows_out(seqSetRows_var& _v) : _ptr(_v._ptr) {
    seqSetRows::_release(_ptr); _ptr = _nil();
  }
  seqSetRows_out& operator=(seqSetRows* _p) {
    _ptr = _p;
    return *this;
  }
  operator seqSetRows_ptr &() { return _ptr; }
  seqSetRows_ptr & ptr() { return _ptr; }
};

struct RowSet {
  seqSetHeader Header;
  seqSetRows Rows;
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

};

VISostream& operator<<(VISostream&, const RowSet& );
VISistream& operator>>(VISistream&, RowSet& );

typedef RowSet* RowSet_ptr;

inline VISistream& operator>>(VISistream& _strm, RowSet_ptr & _obj) {
  _obj = new RowSet;
  _strm >> *_obj;
  return _strm;
}

Ostream& operator<<(Ostream&, const RowSet& );
inline Istream& operator>>(Istream& _strm, RowSet& _obj) {
  VISistream _istrm(_strm);
  _istrm >> _obj;
  return _strm;
}

inline Istream& operator>>(Istream& _strm, RowSet_ptr & _obj) {
  _obj = new RowSet;
  _strm >> *_obj;
  return _strm;
}

class RowSet_out;

class RowSet_var {
  friend class RowSet_out;
private:
  RowSet* _ptr;

public:
  RowSet_var() { _ptr = (RowSet*)NULL;}
  RowSet_var(RowSet *_p) { _ptr = _p; }
  RowSet_var(const RowSet_var& _var) {
    if (_var._ptr)
      _ptr = new RowSet(*_var._ptr);
    else
      _ptr = (RowSet *)NULL;
  }

  ~RowSet_var() {
    if (_ptr != (RowSet *)NULL) delete _ptr;
  }

  RowSet_var& operator=(RowSet *_p) {
    if (_ptr != (RowSet *)NULL) delete _ptr;
    _ptr = _p;
    return *this;
  }

  RowSet_var& operator=(const RowSet_var& _var) {
    if (_ptr != (RowSet *)NULL) delete _ptr;
    if (_var._ptr)
      _ptr = new RowSet(*_var._ptr);
    else
      _ptr = (RowSet *)NULL;
    return *this;
  }

  RowSet *operator->() { return _ptr; }
  operator RowSet *() const { return _ptr; }
  operator RowSet& () { return *_ptr; }
  const RowSet& in() const { return *_ptr; }
  RowSet& inout() { return *_ptr; }
  RowSet_ptr & out();
  RowSet* _retn() {
    RowSet* temp_ptr;
    temp_ptr = _ptr;
    _ptr = (RowSet *)NULL;
    return temp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const RowSet_var& _var) {
    if (_var._ptr == (RowSet *)NULL)
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend VISistream& operator>>(
      VISistream& _strm,
      RowSet_var& _var) {
    if ( !_var._ptr )
      _var._ptr = new RowSet;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class RowSet_out {
private:
  RowSet_ptr & _ptr;
  static RowSet* _nil() { return (RowSet*)NULL; }
  void operator=(const RowSet_out&);
  void operator=(const RowSet_var&);

public:
  RowSet_out(const RowSet_out& _o) : _ptr(_o._ptr) {}
  RowSet_out(RowSet_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  RowSet_out(RowSet_var& _v) : _ptr(_v._ptr) {
    delete _ptr; _ptr = _nil();
  }
  RowSet_out& operator=(RowSet* _p) {
    _ptr = _p;
    return *this;
  }
  operator RowSet_ptr &() { return _ptr; }
  RowSet_ptr & ptr() { return _ptr; }
  RowSet* operator->() { return _ptr; }
};


#ifndef _Cartrige_var_
#define _Cartrige_var_

class Cartrige;
typedef Cartrige* Cartrige_ptr;
typedef Cartrige_ptr CartrigeRef;

 VISistream& operator>>(VISistream&, Cartrige_ptr&);
 VISostream& operator<<(VISostream&, const Cartrige_ptr);

class Cartrige_out;
class Cartrige_var: public CORBA::_var {
  friend class Cartrige_out;

private:
  Cartrige_ptr _ptr;

public:
  void operator=(const Cartrige_var&_v) {
    if ( _ptr ) _release(_ptr);
    if ( _v._ptr )
      _ptr = _duplicate(_v._ptr);
    else
      _ptr = (Cartrige_ptr)NULL;
  }

  static Cartrige_ptr _duplicate(Cartrige_ptr);
  static void _release(Cartrige_ptr);

  Cartrige_var();
  Cartrige_var(Cartrige_ptr);
  Cartrige_var(const Cartrige_var&);
  ~Cartrige_var();
  Cartrige_var& operator=(Cartrige_ptr);
  operator Cartrige_ptr() const { return _ptr; }
  Cartrige_ptr operator->() const { return _ptr; }
  Cartrige_ptr in() const { return _ptr; }
  Cartrige_ptr& inout() { return _ptr; }
  Cartrige_ptr& out();
  Cartrige_ptr _retn() {
    Cartrige_ptr _tmp_ptr;
    _tmp_ptr = _ptr;
    _ptr = (Cartrige_ptr)NULL;
    return _tmp_ptr;
  }
  friend VISistream& operator>>(VISistream&, Cartrige_var&);
  friend VISostream& operator<<(VISostream&, const Cartrige_var&);
  friend Istream& operator>>(Istream&, Cartrige_var&);
  friend Ostream& operator<<(Ostream&, const Cartrige_var&);
};

class Cartrige_out {
private:
  Cartrige_ptr & _ptr;
  static Cartrige* _nil() { return (Cartrige*)NULL; }
  void operator=(const Cartrige_out&);
  void operator=(const Cartrige_var&);

public:
  Cartrige_out(const Cartrige_out& _o) : _ptr(_o._ptr) {}
  Cartrige_out(Cartrige_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  Cartrige_out(Cartrige_var& _v) : _ptr(_v._ptr) {
      Cartrige_var::_release(_ptr); _ptr = _nil();
  }
  ~Cartrige_out() {}
  Cartrige_out& operator=(Cartrige_ptr _p) {
      _ptr = _p; return *this;
  }
  operator Cartrige_ptr& () { return _ptr; }
  Cartrige_ptr& ptr() { return _ptr; }
  Cartrige_ptr operator->() { return _ptr; }
};


#endif

class Cartrige : public virtual CORBA_Object {
private:
  static const CORBA::TypeInfo _class_info;
  Cartrige(const Cartrige&){ ___root = this; }
  void operator=(const Cartrige&){}

protected:
  Cartrige_ptr ___root;
  void set_root(Cartrige_ptr root) {
    ___root = root;
  }
  
public:
  
  static  const CORBA::TypeInfo *_desc();
  virtual const CORBA::TypeInfo *_type_info() const;
  virtual void *_safe_narrow(const CORBA::TypeInfo& ) const;
  static CORBA::Object *_factory();

  Cartrige_ptr _this();
protected:

  Cartrige(const char *obj_name = NULL): CORBA_Object(obj_name, 1) { ___root = this; }
public:
  virtual ~Cartrige() {}

  static Cartrige_ptr _duplicate(Cartrige_ptr _obj) {
    if ( _obj ) _obj->_ref();
    return _obj;
  }
  static Cartrige_ptr _nil() { return (Cartrige_ptr)NULL; }
  static Cartrige_ptr _narrow(CORBA::Object *_obj);
  static Cartrige_ptr _clone(Cartrige_ptr _obj) {
    CORBA::Object_var _obj_var(__clone(_obj));
    
#if defined(_HPCC_BUG)
    return _narrow(_obj_var.operator CORBA::Object_ptr());
    
#else
    return _narrow(_obj_var);
    
#endif
  }

  static Cartrige_ptr _bind(
      const char *_object_name = NULL,
      const char *_host_name = NULL,
      const CORBA::BindOptions* _opt = NULL,
      CORBA::ORB_ptr _orb = NULL);

  virtual char* Name();
  virtual void Name(const char* _val);

  virtual CORBA::Long OpenCursor(
      const char* _Query,
      const seqParams& _Parameters
      );

  virtual CORBA::Boolean CreateDataBaseObject(
      const seqOctets& _ObjDef
      );

  virtual RowSet* GetRowSet(
      const char* _Query,
      const seqParams& _Parameters
      );

  virtual void Disconnect(
      );

  virtual CORBA::Boolean Connect(
      const seqParams& _InitValues
      );

  virtual CORBA::Boolean Connected();
  
  virtual seqSetRow* GetCursorRow(
      CORBA::Long _Cursor
      );

  virtual seqCartrigeParams* Parameters();
  
  virtual CORBA::Boolean NoMoreRows(
      CORBA::Long _Cursor
      );

  virtual void CloseCursor(
      CORBA::Long _Cursor
      );

  virtual seqSetHeader* GetCursorHeared(
      CORBA::Long _Cursor
      );

  virtual void Exec(
      const char* _Query,
      const seqParams& _Parameters
      );

  friend VISistream& operator>>(VISistream& _strm, Cartrige_ptr& _obj);
  friend VISostream& operator<<(VISostream& _strm, const Cartrige_ptr _obj);
  friend Ostream& operator<<(Ostream& _strm, const Cartrige_ptr _obj) {
    _strm << (CORBA::Object_ptr)_obj;
    return _strm;
  }

  friend Istream& operator>>(Istream& _strm, Cartrige_ptr& _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

};

struct Domain {
  CORBA::String_var Name;
  CORBA::String_var CartrigeName;
  seqParams SetupValues;
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

};

VISostream& operator<<(VISostream&, const Domain& );
VISistream& operator>>(VISistream&, Domain& );

typedef Domain* Domain_ptr;

inline VISistream& operator>>(VISistream& _strm, Domain_ptr & _obj) {
  _obj = new Domain;
  _strm >> *_obj;
  return _strm;
}

Ostream& operator<<(Ostream&, const Domain& );
inline Istream& operator>>(Istream& _strm, Domain& _obj) {
  VISistream _istrm(_strm);
  _istrm >> _obj;
  return _strm;
}

inline Istream& operator>>(Istream& _strm, Domain_ptr & _obj) {
  _obj = new Domain;
  _strm >> *_obj;
  return _strm;
}

class Domain_out;

class Domain_var {
  friend class Domain_out;
private:
  Domain* _ptr;

public:
  Domain_var() { _ptr = (Domain*)NULL;}
  Domain_var(Domain *_p) { _ptr = _p; }
  Domain_var(const Domain_var& _var) {
    if (_var._ptr)
      _ptr = new Domain(*_var._ptr);
    else
      _ptr = (Domain *)NULL;
  }

  ~Domain_var() {
    if (_ptr != (Domain *)NULL) delete _ptr;
  }

  Domain_var& operator=(Domain *_p) {
    if (_ptr != (Domain *)NULL) delete _ptr;
    _ptr = _p;
    return *this;
  }

  Domain_var& operator=(const Domain_var& _var) {
    if (_ptr != (Domain *)NULL) delete _ptr;
    if (_var._ptr)
      _ptr = new Domain(*_var._ptr);
    else
      _ptr = (Domain *)NULL;
    return *this;
  }

  Domain *operator->() { return _ptr; }
  operator Domain *() const { return _ptr; }
  operator Domain& () { return *_ptr; }
  const Domain& in() const { return *_ptr; }
  Domain& inout() { return *_ptr; }
  Domain_ptr & out();
  Domain* _retn() {
    Domain* temp_ptr;
    temp_ptr = _ptr;
    _ptr = (Domain *)NULL;
    return temp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const Domain_var& _var) {
    if (_var._ptr == (Domain *)NULL)
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend VISistream& operator>>(
      VISistream& _strm,
      Domain_var& _var) {
    if ( !_var._ptr )
      _var._ptr = new Domain;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class Domain_out {
private:
  Domain_ptr & _ptr;
  static Domain* _nil() { return (Domain*)NULL; }
  void operator=(const Domain_out&);
  void operator=(const Domain_var&);

public:
  Domain_out(const Domain_out& _o) : _ptr(_o._ptr) {}
  Domain_out(Domain_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  Domain_out(Domain_var& _v) : _ptr(_v._ptr) {
    delete _ptr; _ptr = _nil();
  }
  Domain_out& operator=(Domain* _p) {
    _ptr = _p;
    return *this;
  }
  operator Domain_ptr &() { return _ptr; }
  Domain_ptr & ptr() { return _ptr; }
  Domain* operator->() { return _ptr; }
};

struct ClientSideObjectDef {
  CORBA::String_var ObjBaseType;
  CORBA::String_var ObjSubType;
  seqOctets Definition;
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

};

VISostream& operator<<(VISostream&, const ClientSideObjectDef& );
VISistream& operator>>(VISistream&, ClientSideObjectDef& );

typedef ClientSideObjectDef* ClientSideObjectDef_ptr;

inline VISistream& operator>>(VISistream& _strm, ClientSideObjectDef_ptr & _obj) {
  _obj = new ClientSideObjectDef;
  _strm >> *_obj;
  return _strm;
}

Ostream& operator<<(Ostream&, const ClientSideObjectDef& );
inline Istream& operator>>(Istream& _strm, ClientSideObjectDef& _obj) {
  VISistream _istrm(_strm);
  _istrm >> _obj;
  return _strm;
}

inline Istream& operator>>(Istream& _strm, ClientSideObjectDef_ptr & _obj) {
  _obj = new ClientSideObjectDef;
  _strm >> *_obj;
  return _strm;
}

class ClientSideObjectDef_out;

class ClientSideObjectDef_var {
  friend class ClientSideObjectDef_out;
private:
  ClientSideObjectDef* _ptr;

public:
  ClientSideObjectDef_var() { _ptr = (ClientSideObjectDef*)NULL;}
  ClientSideObjectDef_var(ClientSideObjectDef *_p) { _ptr = _p; }
  ClientSideObjectDef_var(const ClientSideObjectDef_var& _var) {
    if (_var._ptr)
      _ptr = new ClientSideObjectDef(*_var._ptr);
    else
      _ptr = (ClientSideObjectDef *)NULL;
  }

  ~ClientSideObjectDef_var() {
    if (_ptr != (ClientSideObjectDef *)NULL) delete _ptr;
  }

  ClientSideObjectDef_var& operator=(ClientSideObjectDef *_p) {
    if (_ptr != (ClientSideObjectDef *)NULL) delete _ptr;
    _ptr = _p;
    return *this;
  }

  ClientSideObjectDef_var& operator=(const ClientSideObjectDef_var& _var) {
    if (_ptr != (ClientSideObjectDef *)NULL) delete _ptr;
    if (_var._ptr)
      _ptr = new ClientSideObjectDef(*_var._ptr);
    else
      _ptr = (ClientSideObjectDef *)NULL;
    return *this;
  }

  ClientSideObjectDef *operator->() { return _ptr; }
  operator ClientSideObjectDef *() const { return _ptr; }
  operator ClientSideObjectDef& () { return *_ptr; }
  const ClientSideObjectDef& in() const { return *_ptr; }
  ClientSideObjectDef& inout() { return *_ptr; }
  ClientSideObjectDef_ptr & out();
  ClientSideObjectDef* _retn() {
    ClientSideObjectDef* temp_ptr;
    temp_ptr = _ptr;
    _ptr = (ClientSideObjectDef *)NULL;
    return temp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const ClientSideObjectDef_var& _var) {
    if (_var._ptr == (ClientSideObjectDef *)NULL)
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend VISistream& operator>>(
      VISistream& _strm,
      ClientSideObjectDef_var& _var) {
    if ( !_var._ptr )
      _var._ptr = new ClientSideObjectDef;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class ClientSideObjectDef_out {
private:
  ClientSideObjectDef_ptr & _ptr;
  static ClientSideObjectDef* _nil() { return (ClientSideObjectDef*)NULL; }
  void operator=(const ClientSideObjectDef_out&);
  void operator=(const ClientSideObjectDef_var&);

public:
  ClientSideObjectDef_out(const ClientSideObjectDef_out& _o) : _ptr(_o._ptr) {}
  ClientSideObjectDef_out(ClientSideObjectDef_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  ClientSideObjectDef_out(ClientSideObjectDef_var& _v) : _ptr(_v._ptr) {
    delete _ptr; _ptr = _nil();
  }
  ClientSideObjectDef_out& operator=(ClientSideObjectDef* _p) {
    _ptr = _p;
    return *this;
  }
  operator ClientSideObjectDef_ptr &() { return _ptr; }
  ClientSideObjectDef_ptr & ptr() { return _ptr; }
  ClientSideObjectDef* operator->() { return _ptr; }
};

class seqClientSideObjectDefs;
typedef seqClientSideObjectDefs *seqClientSideObjectDefs_ptr;

class seqClientSideObjectDefs {
private:
  ClientSideObjectDef *_contents;
  CORBA::ULong    _count;
  CORBA::ULong    _num_allocated;
  CORBA::Long     _ref_count;

  CORBA::Boolean  _release_flag;
public:
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

  static ClientSideObjectDef *allocbuf(CORBA::ULong _nelems);
  static void freebuf(ClientSideObjectDef *_data);
  seqClientSideObjectDefs(CORBA::ULong _max=0);
  seqClientSideObjectDefs(CORBA::ULong _max,
      CORBA::ULong _len,
      ClientSideObjectDef *_data,
      CORBA::Boolean _release=0);
  seqClientSideObjectDefs(const seqClientSideObjectDefs&);
  ~seqClientSideObjectDefs();

  seqClientSideObjectDefs& operator=(const seqClientSideObjectDefs&);
  CORBA::ULong maximum() const { return _num_allocated; }
  void length(CORBA::ULong _len);
  CORBA::ULong length() const { return _count;}
  ClientSideObjectDef& operator[](CORBA::ULong _index) ;
  const ClientSideObjectDef& operator[](CORBA::ULong _index) const;

  friend VISostream& operator<<(VISostream&, const seqClientSideObjectDefs&);
  inline friend VISostream& operator<<(VISostream& _strm, const seqClientSideObjectDefs *_obj) {
    if ( _obj == (seqClientSideObjectDefs*)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_obj;
    return _strm;
  }

  friend VISistream& operator>>(VISistream&, seqClientSideObjectDefs&);
  inline friend VISistream& operator>>(VISistream& _strm, seqClientSideObjectDefs_ptr & _obj) {
    _obj = new seqClientSideObjectDefs;
    _strm >> *_obj;
    return _strm;
  }

  friend Ostream& operator<<(Ostream&, const seqClientSideObjectDefs&);
  inline friend Istream& operator>>(Istream& _strm, seqClientSideObjectDefs& _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  inline friend Istream& operator>>(Istream& _strm, seqClientSideObjectDefs_ptr & _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

  static seqClientSideObjectDefs *_duplicate(seqClientSideObjectDefs* _ptr) {
    if (_ptr) _ptr->_ref_count++;
    return _ptr;
  }

  static void _release(seqClientSideObjectDefs *_ptr) {
    if (_ptr && ( --_ptr->_ref_count == 0) ) delete _ptr;
  }

};

class seqClientSideObjectDefs_out;

class seqClientSideObjectDefs_var {
  friend class seqClientSideObjectDefs_out;
private:
  seqClientSideObjectDefs *_ptr;

public:
  seqClientSideObjectDefs_var() : _ptr((seqClientSideObjectDefs *)NULL) {}
  seqClientSideObjectDefs_var(seqClientSideObjectDefs *_p) :_ptr(_p) {}
  seqClientSideObjectDefs_var(const seqClientSideObjectDefs_var& _var) :
    _ptr(seqClientSideObjectDefs::_duplicate((seqClientSideObjectDefs *)_var)){}
  ~seqClientSideObjectDefs_var() { seqClientSideObjectDefs::_release(_ptr); }

  seqClientSideObjectDefs_var& operator=(seqClientSideObjectDefs *_p) {
    seqClientSideObjectDefs::_release(_ptr);
    _ptr = _p;
    return *this;
  }

  seqClientSideObjectDefs_var& operator=(const seqClientSideObjectDefs_var& _var) {
    seqClientSideObjectDefs::_release(_ptr);
    _ptr = seqClientSideObjectDefs::_duplicate((seqClientSideObjectDefs *)_var);
    return *this;
  }

  seqClientSideObjectDefs *operator->() { return _ptr; }
  ClientSideObjectDef& operator[](CORBA::ULong _index) {
    return _ptr->operator[](_index);
  }

  const ClientSideObjectDef& operator[](CORBA::ULong _index) const {
    return _ptr->operator[](_index);
  }

  operator seqClientSideObjectDefs *() const { return _ptr; }
  operator const seqClientSideObjectDefs& () const { return *_ptr; }
  operator seqClientSideObjectDefs& () { return *_ptr; }

  const seqClientSideObjectDefs& in() const { return *_ptr; }
  seqClientSideObjectDefs& inout() { return *_ptr; }
  seqClientSideObjectDefs_ptr & out();
  seqClientSideObjectDefs* _retn() {
    seqClientSideObjectDefs* _tmp_ptr;
    _tmp_ptr = _ptr;
    _ptr = (seqClientSideObjectDefs *)NULL;
    return _tmp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const seqClientSideObjectDefs_var& _var) {
    if ( _var._ptr == (seqClientSideObjectDefs *)NULL )
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend  VISistream& operator>>(
      VISistream& _strm,
      seqClientSideObjectDefs_var& _var) {
    if ( _var._ptr == (seqClientSideObjectDefs *)NULL )
      _var._ptr = new seqClientSideObjectDefs;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class seqClientSideObjectDefs_out {
private:
  seqClientSideObjectDefs_ptr & _ptr;
  static seqClientSideObjectDefs* _nil() { return (seqClientSideObjectDefs*)NULL; }
  void operator=(const seqClientSideObjectDefs_out&);
  void operator=(const seqClientSideObjectDefs_var&);

public:
  seqClientSideObjectDefs_out(const seqClientSideObjectDefs_out& _o) : _ptr(_o._ptr) {}
  seqClientSideObjectDefs_out(seqClientSideObjectDefs_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  seqClientSideObjectDefs_out(seqClientSideObjectDefs_var& _v) : _ptr(_v._ptr) {
    seqClientSideObjectDefs::_release(_ptr); _ptr = _nil();
  }
  seqClientSideObjectDefs_out& operator=(seqClientSideObjectDefs* _p) {
    _ptr = _p;
    return *this;
  }
  operator seqClientSideObjectDefs_ptr &() { return _ptr; }
  seqClientSideObjectDefs_ptr & ptr() { return _ptr; }
};

struct Platform {
  CORBA::String_var Name;
  seqClientSideObjectDefs ClientSideObjectDefs;
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

};

VISostream& operator<<(VISostream&, const Platform& );
VISistream& operator>>(VISistream&, Platform& );

typedef Platform* Platform_ptr;

inline VISistream& operator>>(VISistream& _strm, Platform_ptr & _obj) {
  _obj = new Platform;
  _strm >> *_obj;
  return _strm;
}

Ostream& operator<<(Ostream&, const Platform& );
inline Istream& operator>>(Istream& _strm, Platform& _obj) {
  VISistream _istrm(_strm);
  _istrm >> _obj;
  return _strm;
}

inline Istream& operator>>(Istream& _strm, Platform_ptr & _obj) {
  _obj = new Platform;
  _strm >> *_obj;
  return _strm;
}

class Platform_out;

class Platform_var {
  friend class Platform_out;
private:
  Platform* _ptr;

public:
  Platform_var() { _ptr = (Platform*)NULL;}
  Platform_var(Platform *_p) { _ptr = _p; }
  Platform_var(const Platform_var& _var) {
    if (_var._ptr)
      _ptr = new Platform(*_var._ptr);
    else
      _ptr = (Platform *)NULL;
  }

  ~Platform_var() {
    if (_ptr != (Platform *)NULL) delete _ptr;
  }

  Platform_var& operator=(Platform *_p) {
    if (_ptr != (Platform *)NULL) delete _ptr;
    _ptr = _p;
    return *this;
  }

  Platform_var& operator=(const Platform_var& _var) {
    if (_ptr != (Platform *)NULL) delete _ptr;
    if (_var._ptr)
      _ptr = new Platform(*_var._ptr);
    else
      _ptr = (Platform *)NULL;
    return *this;
  }

  Platform *operator->() { return _ptr; }
  operator Platform *() const { return _ptr; }
  operator Platform& () { return *_ptr; }
  const Platform& in() const { return *_ptr; }
  Platform& inout() { return *_ptr; }
  Platform_ptr & out();
  Platform* _retn() {
    Platform* temp_ptr;
    temp_ptr = _ptr;
    _ptr = (Platform *)NULL;
    return temp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const Platform_var& _var) {
    if (_var._ptr == (Platform *)NULL)
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend VISistream& operator>>(
      VISistream& _strm,
      Platform_var& _var) {
    if ( !_var._ptr )
      _var._ptr = new Platform;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class Platform_out {
private:
  Platform_ptr & _ptr;
  static Platform* _nil() { return (Platform*)NULL; }
  void operator=(const Platform_out&);
  void operator=(const Platform_var&);

public:
  Platform_out(const Platform_out& _o) : _ptr(_o._ptr) {}
  Platform_out(Platform_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  Platform_out(Platform_var& _v) : _ptr(_v._ptr) {
    delete _ptr; _ptr = _nil();
  }
  Platform_out& operator=(Platform* _p) {
    _ptr = _p;
    return *this;
  }
  operator Platform_ptr &() { return _ptr; }
  Platform_ptr & ptr() { return _ptr; }
  Platform* operator->() { return _ptr; }
};


#ifndef _AppServer_var_
#define _AppServer_var_

class AppServer;
typedef AppServer* AppServer_ptr;
typedef AppServer_ptr AppServerRef;

 VISistream& operator>>(VISistream&, AppServer_ptr&);
 VISostream& operator<<(VISostream&, const AppServer_ptr);

class AppServer_out;
class AppServer_var: public CORBA::_var {
  friend class AppServer_out;

private:
  AppServer_ptr _ptr;

public:
  void operator=(const AppServer_var&_v) {
    if ( _ptr ) _release(_ptr);
    if ( _v._ptr )
      _ptr = _duplicate(_v._ptr);
    else
      _ptr = (AppServer_ptr)NULL;
  }

  static AppServer_ptr _duplicate(AppServer_ptr);
  static void _release(AppServer_ptr);

  AppServer_var();
  AppServer_var(AppServer_ptr);
  AppServer_var(const AppServer_var&);
  ~AppServer_var();
  AppServer_var& operator=(AppServer_ptr);
  operator AppServer_ptr() const { return _ptr; }
  AppServer_ptr operator->() const { return _ptr; }
  AppServer_ptr in() const { return _ptr; }
  AppServer_ptr& inout() { return _ptr; }
  AppServer_ptr& out();
  AppServer_ptr _retn() {
    AppServer_ptr _tmp_ptr;
    _tmp_ptr = _ptr;
    _ptr = (AppServer_ptr)NULL;
    return _tmp_ptr;
  }
  friend VISistream& operator>>(VISistream&, AppServer_var&);
  friend VISostream& operator<<(VISostream&, const AppServer_var&);
  friend Istream& operator>>(Istream&, AppServer_var&);
  friend Ostream& operator<<(Ostream&, const AppServer_var&);
};

class AppServer_out {
private:
  AppServer_ptr & _ptr;
  static AppServer* _nil() { return (AppServer*)NULL; }
  void operator=(const AppServer_out&);
  void operator=(const AppServer_var&);

public:
  AppServer_out(const AppServer_out& _o) : _ptr(_o._ptr) {}
  AppServer_out(AppServer_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  AppServer_out(AppServer_var& _v) : _ptr(_v._ptr) {
      AppServer_var::_release(_ptr); _ptr = _nil();
  }
  ~AppServer_out() {}
  AppServer_out& operator=(AppServer_ptr _p) {
      _ptr = _p; return *this;
  }
  operator AppServer_ptr& () { return _ptr; }
  AppServer_ptr& ptr() { return _ptr; }
  AppServer_ptr operator->() { return _ptr; }
};


#endif

class AppServer : public virtual CORBA_Object {
private:
  static const CORBA::TypeInfo _class_info;
  AppServer(const AppServer&){ ___root = this; }
  void operator=(const AppServer&){}

protected:
  AppServer_ptr ___root;
  void set_root(AppServer_ptr root) {
    ___root = root;
  }
  
public:
  
  static  const CORBA::TypeInfo *_desc();
  virtual const CORBA::TypeInfo *_type_info() const;
  virtual void *_safe_narrow(const CORBA::TypeInfo& ) const;
  static CORBA::Object *_factory();

  AppServer_ptr _this();
protected:

  AppServer(const char *obj_name = NULL): CORBA_Object(obj_name, 1) { ___root = this; }
public:
  virtual ~AppServer() {}

  static AppServer_ptr _duplicate(AppServer_ptr _obj) {
    if ( _obj ) _obj->_ref();
    return _obj;
  }
  static AppServer_ptr _nil() { return (AppServer_ptr)NULL; }
  static AppServer_ptr _narrow(CORBA::Object *_obj);
  static AppServer_ptr _clone(AppServer_ptr _obj) {
    CORBA::Object_var _obj_var(__clone(_obj));
    
#if defined(_HPCC_BUG)
    return _narrow(_obj_var.operator CORBA::Object_ptr());
    
#else
    return _narrow(_obj_var);
    
#endif
  }

  static AppServer_ptr _bind(
      const char *_object_name = NULL,
      const char *_host_name = NULL,
      const CORBA::BindOptions* _opt = NULL,
      CORBA::ORB_ptr _orb = NULL);

  virtual sList* GetSystemDomains(
      const char* _SystemName
      );

  virtual void Logoff(
      );

  virtual char* CurrentSystem();
  
  virtual seqOctets* GetClientSideObject(
      const char* _PlatformName,
      const char* _ObjBaseType,
      const char* _ObjSubType
      );

  virtual Cartrige_ptr GetDomainCartrige(
      const char* _Domain
      );

  virtual CORBA::Boolean Logon(
      const char* _Name,
      const char* _Pass
      );

  virtual void ChooseBuild(
      const char* _SystemName,
      const char* _BuildName
      );

  virtual seqOctets* GetObjectDef(
      const char* _ObjBaseType,
      const char* _ObjectName
      );

  virtual CORBA::Boolean Connected();
  
  virtual seqTwiceStrings* GetBuids(
      );

  virtual void ChangePassword(
      const char* _NewPassword
      );

  virtual seqOctets* GetTask(
      const char* _Task
      );

  virtual char* CurrentBuild();
  
  friend VISistream& operator>>(VISistream& _strm, AppServer_ptr& _obj);
  friend VISostream& operator<<(VISostream& _strm, const AppServer_ptr _obj);
  friend Ostream& operator<<(Ostream& _strm, const AppServer_ptr _obj) {
    _strm << (CORBA::Object_ptr)_obj;
    return _strm;
  }

  friend Istream& operator>>(Istream& _strm, AppServer_ptr& _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

};

struct BuildRight {
  CORBA::String_var BuildName;
  CORBA::String_var SystemName;
  CORBA::String_var GroupName;
  CORBA::String_var UserName;
  CORBA::Boolean IsUser;
  CORBA::Boolean AllowAccess;
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

};

VISostream& operator<<(VISostream&, const BuildRight& );
VISistream& operator>>(VISistream&, BuildRight& );

typedef BuildRight* BuildRight_ptr;

inline VISistream& operator>>(VISistream& _strm, BuildRight_ptr & _obj) {
  _obj = new BuildRight;
  _strm >> *_obj;
  return _strm;
}

Ostream& operator<<(Ostream&, const BuildRight& );
inline Istream& operator>>(Istream& _strm, BuildRight& _obj) {
  VISistream _istrm(_strm);
  _istrm >> _obj;
  return _strm;
}

inline Istream& operator>>(Istream& _strm, BuildRight_ptr & _obj) {
  _obj = new BuildRight;
  _strm >> *_obj;
  return _strm;
}

class BuildRight_out;

class BuildRight_var {
  friend class BuildRight_out;
private:
  BuildRight* _ptr;

public:
  BuildRight_var() { _ptr = (BuildRight*)NULL;}
  BuildRight_var(BuildRight *_p) { _ptr = _p; }
  BuildRight_var(const BuildRight_var& _var) {
    if (_var._ptr)
      _ptr = new BuildRight(*_var._ptr);
    else
      _ptr = (BuildRight *)NULL;
  }

  ~BuildRight_var() {
    if (_ptr != (BuildRight *)NULL) delete _ptr;
  }

  BuildRight_var& operator=(BuildRight *_p) {
    if (_ptr != (BuildRight *)NULL) delete _ptr;
    _ptr = _p;
    return *this;
  }

  BuildRight_var& operator=(const BuildRight_var& _var) {
    if (_ptr != (BuildRight *)NULL) delete _ptr;
    if (_var._ptr)
      _ptr = new BuildRight(*_var._ptr);
    else
      _ptr = (BuildRight *)NULL;
    return *this;
  }

  BuildRight *operator->() { return _ptr; }
  operator BuildRight *() const { return _ptr; }
  operator BuildRight& () { return *_ptr; }
  const BuildRight& in() const { return *_ptr; }
  BuildRight& inout() { return *_ptr; }
  BuildRight_ptr & out();
  BuildRight* _retn() {
    BuildRight* temp_ptr;
    temp_ptr = _ptr;
    _ptr = (BuildRight *)NULL;
    return temp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const BuildRight_var& _var) {
    if (_var._ptr == (BuildRight *)NULL)
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend VISistream& operator>>(
      VISistream& _strm,
      BuildRight_var& _var) {
    if ( !_var._ptr )
      _var._ptr = new BuildRight;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class BuildRight_out {
private:
  BuildRight_ptr & _ptr;
  static BuildRight* _nil() { return (BuildRight*)NULL; }
  void operator=(const BuildRight_out&);
  void operator=(const BuildRight_var&);

public:
  BuildRight_out(const BuildRight_out& _o) : _ptr(_o._ptr) {}
  BuildRight_out(BuildRight_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  BuildRight_out(BuildRight_var& _v) : _ptr(_v._ptr) {
    delete _ptr; _ptr = _nil();
  }
  BuildRight_out& operator=(BuildRight* _p) {
    _ptr = _p;
    return *this;
  }
  operator BuildRight_ptr &() { return _ptr; }
  BuildRight_ptr & ptr() { return _ptr; }
  BuildRight* operator->() { return _ptr; }
};

struct TaskRight {
  CORBA::String_var BuildName;
  CORBA::String_var SystemName;
  CORBA::String_var TaskName;
  CORBA::String_var GroupName;
  CORBA::String_var UserName;
  CORBA::Boolean IsUser;
  CORBA::Boolean AllowExec;
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

};

VISostream& operator<<(VISostream&, const TaskRight& );
VISistream& operator>>(VISistream&, TaskRight& );

typedef TaskRight* TaskRight_ptr;

inline VISistream& operator>>(VISistream& _strm, TaskRight_ptr & _obj) {
  _obj = new TaskRight;
  _strm >> *_obj;
  return _strm;
}

Ostream& operator<<(Ostream&, const TaskRight& );
inline Istream& operator>>(Istream& _strm, TaskRight& _obj) {
  VISistream _istrm(_strm);
  _istrm >> _obj;
  return _strm;
}

inline Istream& operator>>(Istream& _strm, TaskRight_ptr & _obj) {
  _obj = new TaskRight;
  _strm >> *_obj;
  return _strm;
}

class TaskRight_out;

class TaskRight_var {
  friend class TaskRight_out;
private:
  TaskRight* _ptr;

public:
  TaskRight_var() { _ptr = (TaskRight*)NULL;}
  TaskRight_var(TaskRight *_p) { _ptr = _p; }
  TaskRight_var(const TaskRight_var& _var) {
    if (_var._ptr)
      _ptr = new TaskRight(*_var._ptr);
    else
      _ptr = (TaskRight *)NULL;
  }

  ~TaskRight_var() {
    if (_ptr != (TaskRight *)NULL) delete _ptr;
  }

  TaskRight_var& operator=(TaskRight *_p) {
    if (_ptr != (TaskRight *)NULL) delete _ptr;
    _ptr = _p;
    return *this;
  }

  TaskRight_var& operator=(const TaskRight_var& _var) {
    if (_ptr != (TaskRight *)NULL) delete _ptr;
    if (_var._ptr)
      _ptr = new TaskRight(*_var._ptr);
    else
      _ptr = (TaskRight *)NULL;
    return *this;
  }

  TaskRight *operator->() { return _ptr; }
  operator TaskRight *() const { return _ptr; }
  operator TaskRight& () { return *_ptr; }
  const TaskRight& in() const { return *_ptr; }
  TaskRight& inout() { return *_ptr; }
  TaskRight_ptr & out();
  TaskRight* _retn() {
    TaskRight* temp_ptr;
    temp_ptr = _ptr;
    _ptr = (TaskRight *)NULL;
    return temp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const TaskRight_var& _var) {
    if (_var._ptr == (TaskRight *)NULL)
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend VISistream& operator>>(
      VISistream& _strm,
      TaskRight_var& _var) {
    if ( !_var._ptr )
      _var._ptr = new TaskRight;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class TaskRight_out {
private:
  TaskRight_ptr & _ptr;
  static TaskRight* _nil() { return (TaskRight*)NULL; }
  void operator=(const TaskRight_out&);
  void operator=(const TaskRight_var&);

public:
  TaskRight_out(const TaskRight_out& _o) : _ptr(_o._ptr) {}
  TaskRight_out(TaskRight_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  TaskRight_out(TaskRight_var& _v) : _ptr(_v._ptr) {
    delete _ptr; _ptr = _nil();
  }
  TaskRight_out& operator=(TaskRight* _p) {
    _ptr = _p;
    return *this;
  }
  operator TaskRight_ptr &() { return _ptr; }
  TaskRight_ptr & ptr() { return _ptr; }
  TaskRight* operator->() { return _ptr; }
};

struct ObjectRight {
  CORBA::String_var BuildName;
  CORBA::String_var SystemName;
  CORBA::String_var ObjectName;
  CORBA::String_var GroupName;
  CORBA::String_var UserName;
  CORBA::Boolean IsUser;
  CORBA::Boolean AllowExec;
  CORBA::Boolean AllowRead;
  CORBA::Boolean AllowWrite;
  
#if defined(MSVCNEWDLL_BUG)
  void *operator new(size_t ts);
  void *operator new(size_t ts, char*, int) {return operator new(ts);}
  void operator delete(void *p);
  
#endif

};

VISostream& operator<<(VISostream&, const ObjectRight& );
VISistream& operator>>(VISistream&, ObjectRight& );

typedef ObjectRight* ObjectRight_ptr;

inline VISistream& operator>>(VISistream& _strm, ObjectRight_ptr & _obj) {
  _obj = new ObjectRight;
  _strm >> *_obj;
  return _strm;
}

Ostream& operator<<(Ostream&, const ObjectRight& );
inline Istream& operator>>(Istream& _strm, ObjectRight& _obj) {
  VISistream _istrm(_strm);
  _istrm >> _obj;
  return _strm;
}

inline Istream& operator>>(Istream& _strm, ObjectRight_ptr & _obj) {
  _obj = new ObjectRight;
  _strm >> *_obj;
  return _strm;
}

class ObjectRight_out;

class ObjectRight_var {
  friend class ObjectRight_out;
private:
  ObjectRight* _ptr;

public:
  ObjectRight_var() { _ptr = (ObjectRight*)NULL;}
  ObjectRight_var(ObjectRight *_p) { _ptr = _p; }
  ObjectRight_var(const ObjectRight_var& _var) {
    if (_var._ptr)
      _ptr = new ObjectRight(*_var._ptr);
    else
      _ptr = (ObjectRight *)NULL;
  }

  ~ObjectRight_var() {
    if (_ptr != (ObjectRight *)NULL) delete _ptr;
  }

  ObjectRight_var& operator=(ObjectRight *_p) {
    if (_ptr != (ObjectRight *)NULL) delete _ptr;
    _ptr = _p;
    return *this;
  }

  ObjectRight_var& operator=(const ObjectRight_var& _var) {
    if (_ptr != (ObjectRight *)NULL) delete _ptr;
    if (_var._ptr)
      _ptr = new ObjectRight(*_var._ptr);
    else
      _ptr = (ObjectRight *)NULL;
    return *this;
  }

  ObjectRight *operator->() { return _ptr; }
  operator ObjectRight *() const { return _ptr; }
  operator ObjectRight& () { return *_ptr; }
  const ObjectRight& in() const { return *_ptr; }
  ObjectRight& inout() { return *_ptr; }
  ObjectRight_ptr & out();
  ObjectRight* _retn() {
    ObjectRight* temp_ptr;
    temp_ptr = _ptr;
    _ptr = (ObjectRight *)NULL;
    return temp_ptr;
  }
  inline friend VISostream& operator<<(
      VISostream& _strm,
      const ObjectRight_var& _var) {
    if (_var._ptr == (ObjectRight *)NULL)
      throw CORBA::BAD_PARAM();
    else
      _strm << *_var._ptr;
    return _strm;
  }

  inline friend VISistream& operator>>(
      VISistream& _strm,
      ObjectRight_var& _var) {
    if ( !_var._ptr )
      _var._ptr = new ObjectRight;
    _strm >> *_var._ptr;
    return _strm;
  }

};

class ObjectRight_out {
private:
  ObjectRight_ptr & _ptr;
  static ObjectRight* _nil() { return (ObjectRight*)NULL; }
  void operator=(const ObjectRight_out&);
  void operator=(const ObjectRight_var&);

public:
  ObjectRight_out(const ObjectRight_out& _o) : _ptr(_o._ptr) {}
  ObjectRight_out(ObjectRight_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  ObjectRight_out(ObjectRight_var& _v) : _ptr(_v._ptr) {
    delete _ptr; _ptr = _nil();
  }
  ObjectRight_out& operator=(ObjectRight* _p) {
    _ptr = _p;
    return *this;
  }
  operator ObjectRight_ptr &() { return _ptr; }
  ObjectRight_ptr & ptr() { return _ptr; }
  ObjectRight* operator->() { return _ptr; }
};


#ifndef _AppServerStorageManager_var_
#define _AppServerStorageManager_var_

class AppServerStorageManager;
typedef AppServerStorageManager* AppServerStorageManager_ptr;
typedef AppServerStorageManager_ptr AppServerStorageManagerRef;

 VISistream& operator>>(VISistream&, AppServerStorageManager_ptr&);
 VISostream& operator<<(VISostream&, const AppServerStorageManager_ptr);

class AppServerStorageManager_out;
class AppServerStorageManager_var: public CORBA::_var {
  friend class AppServerStorageManager_out;

private:
  AppServerStorageManager_ptr _ptr;

public:
  void operator=(const AppServerStorageManager_var&_v) {
    if ( _ptr ) _release(_ptr);
    if ( _v._ptr )
      _ptr = _duplicate(_v._ptr);
    else
      _ptr = (AppServerStorageManager_ptr)NULL;
  }

  static AppServerStorageManager_ptr _duplicate(AppServerStorageManager_ptr);
  static void _release(AppServerStorageManager_ptr);

  AppServerStorageManager_var();
  AppServerStorageManager_var(AppServerStorageManager_ptr);
  AppServerStorageManager_var(const AppServerStorageManager_var&);
  ~AppServerStorageManager_var();
  AppServerStorageManager_var& operator=(AppServerStorageManager_ptr);
  operator AppServerStorageManager_ptr() const { return _ptr; }
  AppServerStorageManager_ptr operator->() const { return _ptr; }
  AppServerStorageManager_ptr in() const { return _ptr; }
  AppServerStorageManager_ptr& inout() { return _ptr; }
  AppServerStorageManager_ptr& out();
  AppServerStorageManager_ptr _retn() {
    AppServerStorageManager_ptr _tmp_ptr;
    _tmp_ptr = _ptr;
    _ptr = (AppServerStorageManager_ptr)NULL;
    return _tmp_ptr;
  }
  friend VISistream& operator>>(VISistream&, AppServerStorageManager_var&);
  friend VISostream& operator<<(VISostream&, const AppServerStorageManager_var&);
  friend Istream& operator>>(Istream&, AppServerStorageManager_var&);
  friend Ostream& operator<<(Ostream&, const AppServerStorageManager_var&);
};

class AppServerStorageManager_out {
private:
  AppServerStorageManager_ptr & _ptr;
  static AppServerStorageManager* _nil() { return (AppServerStorageManager*)NULL; }
  void operator=(const AppServerStorageManager_out&);
  void operator=(const AppServerStorageManager_var&);

public:
  AppServerStorageManager_out(const AppServerStorageManager_out& _o) : _ptr(_o._ptr) {}
  AppServerStorageManager_out(AppServerStorageManager_ptr & _p) : _ptr(_p) { 
    _ptr = _nil();
  }
  AppServerStorageManager_out(AppServerStorageManager_var& _v) : _ptr(_v._ptr) {
      AppServerStorageManager_var::_release(_ptr); _ptr = _nil();
  }
  ~AppServerStorageManager_out() {}
  AppServerStorageManager_out& operator=(AppServerStorageManager_ptr _p) {
      _ptr = _p; return *this;
  }
  operator AppServerStorageManager_ptr& () { return _ptr; }
  AppServerStorageManager_ptr& ptr() { return _ptr; }
  AppServerStorageManager_ptr operator->() { return _ptr; }
};


#endif

class AppServerStorageManager : public virtual AppServer {
private:
  static const CORBA::TypeInfo _class_info;
  AppServerStorageManager(const AppServerStorageManager&){ ___root = this; }
  void operator=(const AppServerStorageManager&){}

protected:
  AppServerStorageManager_ptr ___root;
  void set_root(AppServerStorageManager_ptr root) {
    
#if defined(MSVCNESTEDBASE_BUG)

    AppServer::set_root(root);
    
#else

    AppServer::set_root(root);
    
#endif

    ___root = root;
  }
  
public:
  
  static  const CORBA::TypeInfo *_desc();
  virtual const CORBA::TypeInfo *_type_info() const;
  virtual void *_safe_narrow(const CORBA::TypeInfo& ) const;
  static CORBA::Object *_factory();

  AppServerStorageManager_ptr _this();
protected:

  AppServerStorageManager(const char *obj_name = NULL): CORBA_Object(obj_name, 1) { ___root = this; }
public:
  virtual ~AppServerStorageManager() {}

  static AppServerStorageManager_ptr _duplicate(AppServerStorageManager_ptr _obj) {
    if ( _obj ) _obj->_ref();
    return _obj;
  }
  static AppServerStorageManager_ptr _nil() { return (AppServerStorageManager_ptr)NULL; }
  static AppServerStorageManager_ptr _narrow(CORBA::Object *_obj);
  static AppServerStorageManager_ptr _clone(AppServerStorageManager_ptr _obj) {
    CORBA::Object_var _obj_var(__clone(_obj));
    
#if defined(_HPCC_BUG)
    return _narrow(_obj_var.operator CORBA::Object_ptr());
    
#else
    return _narrow(_obj_var);
    
#endif
  }

  static AppServerStorageManager_ptr _bind(
      const char *_object_name = NULL,
      const char *_host_name = NULL,
      const CORBA::BindOptions* _opt = NULL,
      CORBA::ORB_ptr _orb = NULL);

  virtual sList* GetPlatforms(
      );

  virtual CORBA::Boolean DelGroup(
      const char* _GroupName
      );

  virtual CORBA::Boolean AddGroup(
      const char* _GroupName
      );

  virtual CORBA::Boolean DelSystemTask(
      const char* _SystemName,
      const char* _TaskName
      );

  virtual CORBA::Boolean AddSystem(
      const char* _SystemName
      );

  virtual CORBA::Boolean GetBuildRight(
      BuildRight& _Right
      );

  virtual CORBA::Boolean AddSystemObject(
      const char* _SystemName,
      const char* _ObjectName,
      const char* _ObjectBaseType
      );

  virtual sList* GetGroupUsers(
      const char* _GroupName
      );

  virtual CORBA::Boolean DelSystemBuildDomain(
      const char* _SystemName,
      const char* _BuildName,
      const char* _DomainName
      );

  virtual CORBA::Boolean AddSystemBuild(
      const char* _SystemName,
      const char* _BuildName
      );

  virtual CORBA::Boolean DelUserFromGroup(
      const char* _GroupName,
      const char* _UserName
      );

  virtual CORBA::Boolean DelSystemObject(
      const char* _SystemName,
      const char* _ObjectName,
      const char* _ObjectBaseType
      );

  virtual CORBA::Boolean DelSystemBuild(
      const char* _SystemName,
      const char* _BuildName
      );

  virtual sList* GetGroups(
      );

  virtual CORBA::Boolean AddUserToGroup(
      const char* _GroupName,
      const char* _UserName
      );

  virtual CORBA::Boolean SetupSystemObject(
      const char* _SystemName,
      const char* _ObjectName,
      const char* _ObjectBaseType,
      const char* _ObjectSubType,
      const seqOctets& _Octets
      );

  virtual sList* GetBaseTypeList(
      );

  virtual CORBA::Boolean AddClientObject(
      const char* _PlatformName,
      const char* _ObjBaseType,
      const char* _ObjSubType,
      const seqOctets& _Octets
      );

  virtual CORBA::Boolean AddPlatform(
      const char* _Name
      );

  virtual CORBA::Boolean SetupSystemTask(
      const char* _SystemName,
      const char* _TaskName,
      const seqOctets& _Octets
      );

  virtual CORBA::Boolean GetTaskRight(
      TaskRight& _Right
      );

  virtual CORBA::Boolean GetObjectRight(
      ObjectRight& _Right
      );

  virtual CORBA::Boolean DelSystem(
      const char* _SystemName
      );

  virtual CORBA::Boolean DelUser(
      const char* _UserName
      );

  virtual CORBA::Boolean DelClientObject(
      const char* _PlatformName,
      const char* _ObjBaseType,
      const char* _ObjSubType
      );

  virtual CORBA::Boolean SetObjectRight(
      const ObjectRight& _Right
      );

  virtual CORBA::Boolean AddSystemBuildDomain(
      const char* _SystemName,
      const char* _BuildName,
      const char* _DomainName,
      const char* _CartrigeName
      );

  virtual CORBA::Boolean SetBuildRight(
      const BuildRight& _Right
      );

  virtual CORBA::Boolean AddSystemTask(
      const char* _SystemName,
      const char* _TaskName
      );

  virtual CORBA::Boolean SetupSystemBuildDomain(
      const char* _SystemName,
      const char* _BuildName,
      const char* _DomainName,
      const seqParams& _SetupValues
      );

  virtual sList* GetUsers(
      );

  virtual CORBA::Boolean SetTaskRight(
      const TaskRight& _Right
      );

  virtual CORBA::Boolean AddUser(
      const char* _UserName,
      const char* _Password,
      CORBA::Boolean _IsAdmin
      );

  friend VISistream& operator>>(VISistream& _strm, AppServerStorageManager_ptr& _obj);
  friend VISostream& operator<<(VISostream& _strm, const AppServerStorageManager_ptr _obj);
  friend Ostream& operator<<(Ostream& _strm, const AppServerStorageManager_ptr _obj) {
    _strm << (CORBA::Object_ptr)_obj;
    return _strm;
  }

  friend Istream& operator>>(Istream& _strm, AppServerStorageManager_ptr& _obj) {
    VISistream _istrm(_strm);
    _istrm >> _obj;
    return _strm;
  }

};


#include "vpost.h"

#endif

