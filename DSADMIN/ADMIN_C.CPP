
/**
 **************************************************************************
 *                                                                        *
 *                        -- DO NOT MODIFY --                             *
 *  This file is automatically generated by the VisiBroker IDL compiler.  *
 *  Generated code conforms to OMG's IDL-to-C++ 1.1 mapping as specified  *
 *  in OMG Document Number: 96-01-13                                      *
 *                                                                        *
 *  VisiBroker is copyrighted by Visigenic Software, Inc.                 *
 **************************************************************************
 */

#include <corbapch.h>
#pragma hdrstop
#include "admin_c.hh"


#if defined(MSVCNEWDLL_BUG)
void *sList::operator new(size_t ts) {
  return ::operator new(ts);
}

void sList::operator delete(void *p) {
  ::operator delete(p);
}


#endif

char** sList::allocbuf(CORBA::ULong _nelems) {
  char* *ret= new char*[_nelems];
  memset(ret, 0, size_t(_nelems) * sizeof(char*));
  return ret;
}

void sList::freebuf(char* *_data) {
  if (_data) delete[] _data;
}

void sList::freebuf_elems(char* *_data, CORBA::ULong _nelem) {
  if (_data) {
    for (CORBA::ULong i=0; i < _nelem; i++)
      CORBA::string_free(_data[i]);
    delete[] _data;
  }
}

sList::sList(CORBA::ULong _max) {
  _num_allocated = _max;
  _count = 0;
  if (_max > 0)
    _buffer = allocbuf(_max);
  else
    _buffer = (char* *)NULL;
  release_on_copy(1);
  _ref_count = 1;
}

sList::sList(
    CORBA::ULong _max,
    CORBA::ULong _len,
    char* *_data,
    CORBA::Boolean _rel) {
  _num_allocated = _max;
  _count = _len;
  release_on_copy(_rel);
  _buffer = _data;
  _ref_count = 1;
}

sList::sList(const sList& _seq) {
  _num_allocated = _seq._num_allocated;
  _count = _seq._count;
  release_on_copy(1);
  _ref_count = 1;
  if (_num_allocated > 0) {
    _buffer = allocbuf(_num_allocated);
    for (CORBA::ULong i=0; i < _count; i++) {
      if (_seq._buffer[i]) {
        _buffer[i] = CORBA::string_alloc(
            strlen(_seq._buffer[i]));
        strcpy(_buffer[i], _seq._buffer[i]);
      }
    }
  }
  else
    _buffer = (char* *)NULL;
}

sList::~sList() {
  if (release_on_copy())
    freebuf_elems(_buffer, _num_allocated);
}

sList& sList::operator=(const sList& _seq) {
  if (release_on_copy() )
    freebuf_elems(_buffer, _num_allocated);
  release_on_copy(1);
  _num_allocated = _seq._num_allocated;
  _count = _seq._count;
  if (_num_allocated > 0) {
    _buffer = allocbuf(_num_allocated);
    for (CORBA::ULong i=0; i < _count; i++) {
      if (_seq._buffer[i]) {
        _buffer[i] = CORBA::string_alloc(
            strlen(_seq._buffer[i]));
        strcpy(_buffer[i], _seq._buffer[i]);
      }
    }
  }
  else
    _buffer = (char* *)NULL;
  return *this;
}

void sList::length(CORBA::ULong _newlen) {
  if (_newlen > _num_allocated) {
    char* *temp = allocbuf(_newlen);
    if (release_on_copy()) {
      for (CORBA::ULong i=0; i < _count; i++)
        temp[i] = _buffer[i];
      freebuf(_buffer);
    }
    _buffer = temp;
    _num_allocated = _newlen;
  }
  _count = _newlen;
}

VISostream&  operator<<(VISostream& _strm, const sList& _seq) {
  _strm << _seq._count;
  for (CORBA::ULong i=0; i < _seq._count; i++)
    _strm << _seq._buffer[i];
  return _strm;
}

VISistream& operator>>(VISistream& _strm,  sList& _seq) {
  CORBA::ULong t_count;
  _strm >> t_count;
  if (t_count > 0 && ! _strm.is_available(t_count)) {
    throw CORBA::MARSHAL();
  }
  if (t_count > _seq._count) {
    if (_seq._num_allocated < t_count) {
      if (_seq.release_on_copy())
        sList::freebuf_elems(_seq._buffer, _seq._num_allocated);
      _seq._buffer = sList::allocbuf(t_count);
      _seq._num_allocated = t_count;
      _seq.release_on_copy(1);
    }
  }
  _seq._count = t_count;
  for (CORBA::ULong i=0; i < t_count; i++)
    _strm >> _seq._buffer[i];
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const sList& _seq) {
  VISostream _ostrm(_strm);
  _ostrm << _seq;
  return _strm;
}


sList_ptr & sList_var::out() {
  sList::_release(_ptr);
  _ptr = (sList *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *seqOctets::operator new(size_t ts) {
  return ::operator new(ts);
}

void seqOctets::operator delete(void *p) {
  ::operator delete(p);
}


#endif

CORBA::Octet* seqOctets::allocbuf(CORBA::ULong _nelems) {
  return new CORBA::Octet[_nelems];
}

void seqOctets::freebuf(CORBA::Octet *_data) {
  if (_data) delete[] _data;
}

seqOctets::seqOctets(CORBA::ULong _max) {
  _num_allocated = _max;
  _count = 0;
  if (_num_allocated > 0)
    _contents = allocbuf(_num_allocated);
  else
    _contents = (CORBA::Octet *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

seqOctets::seqOctets(
    CORBA::ULong _max,
    CORBA::ULong _len,
    CORBA::Octet *_data,
    CORBA::Boolean _release) {
  _num_allocated = _max;
  _count = _len;
  _contents = _data;
  _release_flag = _release;
  _ref_count = 1;
}

seqOctets::seqOctets(const seqOctets& _seq) {
  _num_allocated = _seq._num_allocated;
  _count = _seq._count;
  if (_num_allocated > 0) {
    _contents = allocbuf(_num_allocated);
    memcpy(_contents, _seq._contents, (size_t(_count) * sizeof(CORBA::Octet)));
  }
  else
    _contents = (CORBA::Octet *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

seqOctets::~seqOctets() {
  if (_release_flag) freebuf(_contents);
}

seqOctets& seqOctets::operator=(const seqOctets& _seq) {
  if (_count < _seq._count) {
    if (_num_allocated < _seq._count) {
      if (_release_flag)
        freebuf(_contents);
      else
        _release_flag = 1;
      _contents = allocbuf(_seq._num_allocated);
      _num_allocated = _seq._num_allocated;
    }
  }
  _count = _seq._count;
  memcpy(_contents, _seq._contents, (size_t(_count) * sizeof(CORBA::Octet)));
  return *this;
}

void seqOctets::length(CORBA::ULong _newlen) {
  if (_newlen > _num_allocated) {
    CORBA::Octet *temp = allocbuf(_newlen);
    memcpy(temp, _contents, (size_t(_count) * sizeof(CORBA::Octet)));
    if (_release_flag)
      freebuf(_contents);
    else
      _release_flag = 1;
    _num_allocated = _newlen;
    _contents = temp;
  }
  if (_newlen > _count)
    memset(&_contents[_count], 0, size_t(_newlen - _count) *
        sizeof(CORBA::Octet));
  _count = _newlen;
}

CORBA::Octet& seqOctets::operator[](CORBA::ULong _index) {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

const CORBA::Octet& seqOctets::operator[](CORBA::ULong _index) const {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

VISostream&  operator<<(VISostream& _strm, const seqOctets& _seq) {
  _strm << _seq._count;
  if (_seq._count > 0)
    _strm.put(_seq._contents, (unsigned int)_seq._count);
  return _strm;
}

VISistream& operator>>(VISistream& _strm,  seqOctets& _seq) {
  CORBA::ULong t_count;
  _strm >> t_count;
  if (t_count > 0 && ! _strm.is_available(t_count)) {
    throw CORBA::MARSHAL();
  }
  if (t_count > _seq._count) {
    if (_seq._num_allocated < t_count) {
      if (_seq._release_flag)
        seqOctets::freebuf(_seq._contents);
      else
        _seq._release_flag = 1;
      _seq._contents = seqOctets::allocbuf(t_count);
      _seq._num_allocated = t_count;
    }
  }
  _seq._count = t_count;
  if (_seq._count > 0)
    _strm.get(_seq._contents, (unsigned int)_seq._count);
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const seqOctets& _seq) {
  VISostream _ostrm(_strm);
  _ostrm << _seq;
  return _strm;
}


seqOctets_ptr & seqOctets_var::out() {
  seqOctets::_release(_ptr);
  _ptr = (seqOctets *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *TwiceString::operator new(size_t ts) {
  return ::operator new(ts);
}

void TwiceString::operator delete(void *p) {
  ::operator delete(p);
}


#endif

VISostream& operator<<(VISostream& _strm, const TwiceString& _s) {
  _strm << _s.Str1;
  _strm << _s.Str2;
  return _strm;
}

VISistream& operator>>(VISistream& _strm, TwiceString& _s) {
  _strm >> _s.Str1;
  _strm >> _s.Str2;
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const TwiceString& _s) {
  VISostream _ostrm(_strm);
  _ostrm << _s;
  return _strm;
}


TwiceString_ptr & TwiceString_var::out() {
  if (_ptr != (TwiceString *)NULL) delete _ptr;
  _ptr = (TwiceString *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *seqTwiceStrings::operator new(size_t ts) {
  return ::operator new(ts);
}

void seqTwiceStrings::operator delete(void *p) {
  ::operator delete(p);
}


#endif

TwiceString* seqTwiceStrings::allocbuf(CORBA::ULong _nelems) {
  return new TwiceString[_nelems];
}

void seqTwiceStrings::freebuf(TwiceString *_data) {
  if (_data) delete[] _data;
}

seqTwiceStrings::seqTwiceStrings(CORBA::ULong _max) {
  _num_allocated = _max;
  _count = 0;
  if (_num_allocated > 0)
    _contents = allocbuf(_num_allocated);
  else
    _contents = (TwiceString *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

seqTwiceStrings::seqTwiceStrings(
    CORBA::ULong _max,
    CORBA::ULong _len,
    TwiceString *_data,
    CORBA::Boolean _release) {
  _num_allocated = _max;
  _count = _len;
  _contents = _data;
  _release_flag = _release;
  _ref_count = 1;
}

seqTwiceStrings::seqTwiceStrings(const seqTwiceStrings& _seq) {
  _num_allocated = _seq._num_allocated;
  _count = _seq._count;
  if (_num_allocated > 0) {
    _contents = allocbuf(_num_allocated);
    for (CORBA::ULong i=0; i < _count; i++) {
      _contents[i] = _seq._contents[i];
    }
  }
  else
    _contents = (TwiceString *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

seqTwiceStrings::~seqTwiceStrings() {
  if (_release_flag) freebuf(_contents);
}

seqTwiceStrings& seqTwiceStrings::operator=(const seqTwiceStrings& _seq) {
  if (_count < _seq._count) {
    if (_num_allocated < _seq._count) {
      if (_release_flag)
        freebuf(_contents);
      else
        _release_flag = 1;
      _contents = allocbuf(_seq._num_allocated);
      _num_allocated = _seq._num_allocated;
    }
  }
  _count = _seq._count;
  for (CORBA::ULong i=0; i < _count; i++) {
    _contents[i] = _seq._contents[i];
  }
  return *this;
}

void seqTwiceStrings::length(CORBA::ULong _newlen) {
  if (_newlen > _num_allocated) {
    TwiceString *temp = allocbuf(_newlen);
    for (CORBA::ULong i=0; i < _count; i++) {
      temp[i] = _contents[i];
    }
    if (_release_flag)
      freebuf(_contents);
    else
      _release_flag = 1;
    _num_allocated = _newlen;
    _contents = temp;
  }
  _count = _newlen;
}

TwiceString& seqTwiceStrings::operator[](CORBA::ULong _index) {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

const TwiceString& seqTwiceStrings::operator[](CORBA::ULong _index) const {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

VISostream&  operator<<(VISostream& _strm, const seqTwiceStrings& _seq) {
  _strm << _seq._count;
  for (CORBA::ULong i=0; i < _seq._count; i++) {
    _strm << _seq._contents[i];
  }
  return _strm;
}

VISistream& operator>>(VISistream& _strm,  seqTwiceStrings& _seq) {
  CORBA::ULong t_count;
  _strm >> t_count;
  if (t_count > 0 && ! _strm.is_available(t_count)) {
    throw CORBA::MARSHAL();
  }
  if (t_count > _seq._count) {
    if (_seq._num_allocated < t_count) {
      if (_seq._release_flag)
        seqTwiceStrings::freebuf(_seq._contents);
      else
        _seq._release_flag = 1;
      _seq._contents = seqTwiceStrings::allocbuf(t_count);
      _seq._num_allocated = t_count;
    }
  }
  _seq._count = t_count;
  for (CORBA::ULong i=0; i < _seq._count; i++) {
    _strm >> _seq._contents[i];
  }
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const seqTwiceStrings& _seq) {
  VISostream _ostrm(_strm);
  _ostrm << _seq;
  return _strm;
}


seqTwiceStrings_ptr & seqTwiceStrings_var::out() {
  seqTwiceStrings::_release(_ptr);
  _ptr = (seqTwiceStrings *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *SetDataField::operator new(size_t ts) {
  return ::operator new(ts);
}

void SetDataField::operator delete(void *p) {
  ::operator delete(p);
}


#endif

VISostream& operator<<(VISostream& _strm, const SetDataField& _s) {
  _strm << _s.IsNull;
  _strm << _s.FType;
  _strm << _s.vData;
  return _strm;
}

VISistream& operator>>(VISistream& _strm, SetDataField& _s) {
  _strm >> _s.IsNull;
  _strm >> _s.FType;
  _strm >> _s.vData;
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const SetDataField& _s) {
  VISostream _ostrm(_strm);
  _ostrm << _s;
  return _strm;
}


SetDataField_ptr & SetDataField_var::out() {
  if (_ptr != (SetDataField *)NULL) delete _ptr;
  _ptr = (SetDataField *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *Param::operator new(size_t ts) {
  return ::operator new(ts);
}

void Param::operator delete(void *p) {
  ::operator delete(p);
}


#endif

VISostream& operator<<(VISostream& _strm, const Param& _s) {
  _strm << _s.Name;
  _strm << _s.Value;
  return _strm;
}

VISistream& operator>>(VISistream& _strm, Param& _s) {
  _strm >> _s.Name;
  _strm >> _s.Value;
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const Param& _s) {
  VISostream _ostrm(_strm);
  _ostrm << _s;
  return _strm;
}


Param_ptr & Param_var::out() {
  if (_ptr != (Param *)NULL) delete _ptr;
  _ptr = (Param *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *seqParams::operator new(size_t ts) {
  return ::operator new(ts);
}

void seqParams::operator delete(void *p) {
  ::operator delete(p);
}


#endif

Param* seqParams::allocbuf(CORBA::ULong _nelems) {
  return new Param[_nelems];
}

void seqParams::freebuf(Param *_data) {
  if (_data) delete[] _data;
}

seqParams::seqParams(CORBA::ULong _max) {
  _num_allocated = _max;
  _count = 0;
  if (_num_allocated > 0)
    _contents = allocbuf(_num_allocated);
  else
    _contents = (Param *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

seqParams::seqParams(
    CORBA::ULong _max,
    CORBA::ULong _len,
    Param *_data,
    CORBA::Boolean _release) {
  _num_allocated = _max;
  _count = _len;
  _contents = _data;
  _release_flag = _release;
  _ref_count = 1;
}

seqParams::seqParams(const seqParams& _seq) {
  _num_allocated = _seq._num_allocated;
  _count = _seq._count;
  if (_num_allocated > 0) {
    _contents = allocbuf(_num_allocated);
    for (CORBA::ULong i=0; i < _count; i++) {
      _contents[i] = _seq._contents[i];
    }
  }
  else
    _contents = (Param *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

seqParams::~seqParams() {
  if (_release_flag) freebuf(_contents);
}

seqParams& seqParams::operator=(const seqParams& _seq) {
  if (_count < _seq._count) {
    if (_num_allocated < _seq._count) {
      if (_release_flag)
        freebuf(_contents);
      else
        _release_flag = 1;
      _contents = allocbuf(_seq._num_allocated);
      _num_allocated = _seq._num_allocated;
    }
  }
  _count = _seq._count;
  for (CORBA::ULong i=0; i < _count; i++) {
    _contents[i] = _seq._contents[i];
  }
  return *this;
}

void seqParams::length(CORBA::ULong _newlen) {
  if (_newlen > _num_allocated) {
    Param *temp = allocbuf(_newlen);
    for (CORBA::ULong i=0; i < _count; i++) {
      temp[i] = _contents[i];
    }
    if (_release_flag)
      freebuf(_contents);
    else
      _release_flag = 1;
    _num_allocated = _newlen;
    _contents = temp;
  }
  _count = _newlen;
}

Param& seqParams::operator[](CORBA::ULong _index) {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

const Param& seqParams::operator[](CORBA::ULong _index) const {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

VISostream&  operator<<(VISostream& _strm, const seqParams& _seq) {
  _strm << _seq._count;
  for (CORBA::ULong i=0; i < _seq._count; i++) {
    _strm << _seq._contents[i];
  }
  return _strm;
}

VISistream& operator>>(VISistream& _strm,  seqParams& _seq) {
  CORBA::ULong t_count;
  _strm >> t_count;
  if (t_count > 0 && ! _strm.is_available(t_count)) {
    throw CORBA::MARSHAL();
  }
  if (t_count > _seq._count) {
    if (_seq._num_allocated < t_count) {
      if (_seq._release_flag)
        seqParams::freebuf(_seq._contents);
      else
        _seq._release_flag = 1;
      _seq._contents = seqParams::allocbuf(t_count);
      _seq._num_allocated = t_count;
    }
  }
  _seq._count = t_count;
  for (CORBA::ULong i=0; i < _seq._count; i++) {
    _strm >> _seq._contents[i];
  }
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const seqParams& _seq) {
  VISostream _ostrm(_strm);
  _ostrm << _seq;
  return _strm;
}


seqParams_ptr & seqParams_var::out() {
  seqParams::_release(_ptr);
  _ptr = (seqParams *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *CartrigeParam::operator new(size_t ts) {
  return ::operator new(ts);
}

void CartrigeParam::operator delete(void *p) {
  ::operator delete(p);
}


#endif

VISostream& operator<<(VISostream& _strm, const CartrigeParam& _s) {
  _strm << _s.Name;
  _strm << _s.AllowNull;
  return _strm;
}

VISistream& operator>>(VISistream& _strm, CartrigeParam& _s) {
  _strm >> _s.Name;
  _strm >> _s.AllowNull;
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const CartrigeParam& _s) {
  VISostream _ostrm(_strm);
  _ostrm << _s;
  return _strm;
}


CartrigeParam_ptr & CartrigeParam_var::out() {
  if (_ptr != (CartrigeParam *)NULL) delete _ptr;
  _ptr = (CartrigeParam *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *seqCartrigeParams::operator new(size_t ts) {
  return ::operator new(ts);
}

void seqCartrigeParams::operator delete(void *p) {
  ::operator delete(p);
}


#endif

CartrigeParam* seqCartrigeParams::allocbuf(CORBA::ULong _nelems) {
  return new CartrigeParam[_nelems];
}

void seqCartrigeParams::freebuf(CartrigeParam *_data) {
  if (_data) delete[] _data;
}

seqCartrigeParams::seqCartrigeParams(CORBA::ULong _max) {
  _num_allocated = _max;
  _count = 0;
  if (_num_allocated > 0)
    _contents = allocbuf(_num_allocated);
  else
    _contents = (CartrigeParam *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

seqCartrigeParams::seqCartrigeParams(
    CORBA::ULong _max,
    CORBA::ULong _len,
    CartrigeParam *_data,
    CORBA::Boolean _release) {
  _num_allocated = _max;
  _count = _len;
  _contents = _data;
  _release_flag = _release;
  _ref_count = 1;
}

seqCartrigeParams::seqCartrigeParams(const seqCartrigeParams& _seq) {
  _num_allocated = _seq._num_allocated;
  _count = _seq._count;
  if (_num_allocated > 0) {
    _contents = allocbuf(_num_allocated);
    for (CORBA::ULong i=0; i < _count; i++) {
      _contents[i] = _seq._contents[i];
    }
  }
  else
    _contents = (CartrigeParam *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

seqCartrigeParams::~seqCartrigeParams() {
  if (_release_flag) freebuf(_contents);
}

seqCartrigeParams& seqCartrigeParams::operator=(const seqCartrigeParams& _seq) {
  if (_count < _seq._count) {
    if (_num_allocated < _seq._count) {
      if (_release_flag)
        freebuf(_contents);
      else
        _release_flag = 1;
      _contents = allocbuf(_seq._num_allocated);
      _num_allocated = _seq._num_allocated;
    }
  }
  _count = _seq._count;
  for (CORBA::ULong i=0; i < _count; i++) {
    _contents[i] = _seq._contents[i];
  }
  return *this;
}

void seqCartrigeParams::length(CORBA::ULong _newlen) {
  if (_newlen > _num_allocated) {
    CartrigeParam *temp = allocbuf(_newlen);
    for (CORBA::ULong i=0; i < _count; i++) {
      temp[i] = _contents[i];
    }
    if (_release_flag)
      freebuf(_contents);
    else
      _release_flag = 1;
    _num_allocated = _newlen;
    _contents = temp;
  }
  _count = _newlen;
}

CartrigeParam& seqCartrigeParams::operator[](CORBA::ULong _index) {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

const CartrigeParam& seqCartrigeParams::operator[](CORBA::ULong _index) const {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

VISostream&  operator<<(VISostream& _strm, const seqCartrigeParams& _seq) {
  _strm << _seq._count;
  for (CORBA::ULong i=0; i < _seq._count; i++) {
    _strm << _seq._contents[i];
  }
  return _strm;
}

VISistream& operator>>(VISistream& _strm,  seqCartrigeParams& _seq) {
  CORBA::ULong t_count;
  _strm >> t_count;
  if (t_count > 0 && ! _strm.is_available(t_count)) {
    throw CORBA::MARSHAL();
  }
  if (t_count > _seq._count) {
    if (_seq._num_allocated < t_count) {
      if (_seq._release_flag)
        seqCartrigeParams::freebuf(_seq._contents);
      else
        _seq._release_flag = 1;
      _seq._contents = seqCartrigeParams::allocbuf(t_count);
      _seq._num_allocated = t_count;
    }
  }
  _seq._count = t_count;
  for (CORBA::ULong i=0; i < _seq._count; i++) {
    _strm >> _seq._contents[i];
  }
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const seqCartrigeParams& _seq) {
  VISostream _ostrm(_strm);
  _ostrm << _seq;
  return _strm;
}


seqCartrigeParams_ptr & seqCartrigeParams_var::out() {
  seqCartrigeParams::_release(_ptr);
  _ptr = (seqCartrigeParams *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *SetHeaderField::operator new(size_t ts) {
  return ::operator new(ts);
}

void SetHeaderField::operator delete(void *p) {
  ::operator delete(p);
}


#endif

VISostream& operator<<(VISostream& _strm, const SetHeaderField& _s) {
  _strm << _s.Name;
  _strm << _s.FType;
  _strm << _s.AllowNull;
  _strm << _s.MaxSize;
  return _strm;
}

VISistream& operator>>(VISistream& _strm, SetHeaderField& _s) {
  _strm >> _s.Name;
  _strm >> _s.FType;
  _strm >> _s.AllowNull;
  _strm >> _s.MaxSize;
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const SetHeaderField& _s) {
  VISostream _ostrm(_strm);
  _ostrm << _s;
  return _strm;
}


SetHeaderField_ptr & SetHeaderField_var::out() {
  if (_ptr != (SetHeaderField *)NULL) delete _ptr;
  _ptr = (SetHeaderField *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *seqSetHeader::operator new(size_t ts) {
  return ::operator new(ts);
}

void seqSetHeader::operator delete(void *p) {
  ::operator delete(p);
}


#endif

SetHeaderField* seqSetHeader::allocbuf(CORBA::ULong _nelems) {
  return new SetHeaderField[_nelems];
}

void seqSetHeader::freebuf(SetHeaderField *_data) {
  if (_data) delete[] _data;
}

seqSetHeader::seqSetHeader(CORBA::ULong _max) {
  _num_allocated = _max;
  _count = 0;
  if (_num_allocated > 0)
    _contents = allocbuf(_num_allocated);
  else
    _contents = (SetHeaderField *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

seqSetHeader::seqSetHeader(
    CORBA::ULong _max,
    CORBA::ULong _len,
    SetHeaderField *_data,
    CORBA::Boolean _release) {
  _num_allocated = _max;
  _count = _len;
  _contents = _data;
  _release_flag = _release;
  _ref_count = 1;
}

seqSetHeader::seqSetHeader(const seqSetHeader& _seq) {
  _num_allocated = _seq._num_allocated;
  _count = _seq._count;
  if (_num_allocated > 0) {
    _contents = allocbuf(_num_allocated);
    for (CORBA::ULong i=0; i < _count; i++) {
      _contents[i] = _seq._contents[i];
    }
  }
  else
    _contents = (SetHeaderField *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

seqSetHeader::~seqSetHeader() {
  if (_release_flag) freebuf(_contents);
}

seqSetHeader& seqSetHeader::operator=(const seqSetHeader& _seq) {
  if (_count < _seq._count) {
    if (_num_allocated < _seq._count) {
      if (_release_flag)
        freebuf(_contents);
      else
        _release_flag = 1;
      _contents = allocbuf(_seq._num_allocated);
      _num_allocated = _seq._num_allocated;
    }
  }
  _count = _seq._count;
  for (CORBA::ULong i=0; i < _count; i++) {
    _contents[i] = _seq._contents[i];
  }
  return *this;
}

void seqSetHeader::length(CORBA::ULong _newlen) {
  if (_newlen > _num_allocated) {
    SetHeaderField *temp = allocbuf(_newlen);
    for (CORBA::ULong i=0; i < _count; i++) {
      temp[i] = _contents[i];
    }
    if (_release_flag)
      freebuf(_contents);
    else
      _release_flag = 1;
    _num_allocated = _newlen;
    _contents = temp;
  }
  _count = _newlen;
}

SetHeaderField& seqSetHeader::operator[](CORBA::ULong _index) {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

const SetHeaderField& seqSetHeader::operator[](CORBA::ULong _index) const {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

VISostream&  operator<<(VISostream& _strm, const seqSetHeader& _seq) {
  _strm << _seq._count;
  for (CORBA::ULong i=0; i < _seq._count; i++) {
    _strm << _seq._contents[i];
  }
  return _strm;
}

VISistream& operator>>(VISistream& _strm,  seqSetHeader& _seq) {
  CORBA::ULong t_count;
  _strm >> t_count;
  if (t_count > 0 && ! _strm.is_available(t_count)) {
    throw CORBA::MARSHAL();
  }
  if (t_count > _seq._count) {
    if (_seq._num_allocated < t_count) {
      if (_seq._release_flag)
        seqSetHeader::freebuf(_seq._contents);
      else
        _seq._release_flag = 1;
      _seq._contents = seqSetHeader::allocbuf(t_count);
      _seq._num_allocated = t_count;
    }
  }
  _seq._count = t_count;
  for (CORBA::ULong i=0; i < _seq._count; i++) {
    _strm >> _seq._contents[i];
  }
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const seqSetHeader& _seq) {
  VISostream _ostrm(_strm);
  _ostrm << _seq;
  return _strm;
}


seqSetHeader_ptr & seqSetHeader_var::out() {
  seqSetHeader::_release(_ptr);
  _ptr = (seqSetHeader *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *seqSetRow::operator new(size_t ts) {
  return ::operator new(ts);
}

void seqSetRow::operator delete(void *p) {
  ::operator delete(p);
}


#endif

SetDataField* seqSetRow::allocbuf(CORBA::ULong _nelems) {
  return new SetDataField[_nelems];
}

void seqSetRow::freebuf(SetDataField *_data) {
  if (_data) delete[] _data;
}

seqSetRow::seqSetRow(CORBA::ULong _max) {
  _num_allocated = _max;
  _count = 0;
  if (_num_allocated > 0)
    _contents = allocbuf(_num_allocated);
  else
    _contents = (SetDataField *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

seqSetRow::seqSetRow(
    CORBA::ULong _max,
    CORBA::ULong _len,
    SetDataField *_data,
    CORBA::Boolean _release) {
  _num_allocated = _max;
  _count = _len;
  _contents = _data;
  _release_flag = _release;
  _ref_count = 1;
}

seqSetRow::seqSetRow(const seqSetRow& _seq) {
  _num_allocated = _seq._num_allocated;
  _count = _seq._count;
  if (_num_allocated > 0) {
    _contents = allocbuf(_num_allocated);
    for (CORBA::ULong i=0; i < _count; i++) {
      _contents[i] = _seq._contents[i];
    }
  }
  else
    _contents = (SetDataField *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

seqSetRow::~seqSetRow() {
  if (_release_flag) freebuf(_contents);
}

seqSetRow& seqSetRow::operator=(const seqSetRow& _seq) {
  if (_count < _seq._count) {
    if (_num_allocated < _seq._count) {
      if (_release_flag)
        freebuf(_contents);
      else
        _release_flag = 1;
      _contents = allocbuf(_seq._num_allocated);
      _num_allocated = _seq._num_allocated;
    }
  }
  _count = _seq._count;
  for (CORBA::ULong i=0; i < _count; i++) {
    _contents[i] = _seq._contents[i];
  }
  return *this;
}

void seqSetRow::length(CORBA::ULong _newlen) {
  if (_newlen > _num_allocated) {
    SetDataField *temp = allocbuf(_newlen);
    for (CORBA::ULong i=0; i < _count; i++) {
      temp[i] = _contents[i];
    }
    if (_release_flag)
      freebuf(_contents);
    else
      _release_flag = 1;
    _num_allocated = _newlen;
    _contents = temp;
  }
  _count = _newlen;
}

SetDataField& seqSetRow::operator[](CORBA::ULong _index) {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

const SetDataField& seqSetRow::operator[](CORBA::ULong _index) const {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

VISostream&  operator<<(VISostream& _strm, const seqSetRow& _seq) {
  _strm << _seq._count;
  for (CORBA::ULong i=0; i < _seq._count; i++) {
    _strm << _seq._contents[i];
  }
  return _strm;
}

VISistream& operator>>(VISistream& _strm,  seqSetRow& _seq) {
  CORBA::ULong t_count;
  _strm >> t_count;
  if (t_count > 0 && ! _strm.is_available(t_count)) {
    throw CORBA::MARSHAL();
  }
  if (t_count > _seq._count) {
    if (_seq._num_allocated < t_count) {
      if (_seq._release_flag)
        seqSetRow::freebuf(_seq._contents);
      else
        _seq._release_flag = 1;
      _seq._contents = seqSetRow::allocbuf(t_count);
      _seq._num_allocated = t_count;
    }
  }
  _seq._count = t_count;
  for (CORBA::ULong i=0; i < _seq._count; i++) {
    _strm >> _seq._contents[i];
  }
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const seqSetRow& _seq) {
  VISostream _ostrm(_strm);
  _ostrm << _seq;
  return _strm;
}


seqSetRow_ptr & seqSetRow_var::out() {
  seqSetRow::_release(_ptr);
  _ptr = (seqSetRow *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *seqSetRows::operator new(size_t ts) {
  return ::operator new(ts);
}

void seqSetRows::operator delete(void *p) {
  ::operator delete(p);
}


#endif

seqSetRow* seqSetRows::allocbuf(CORBA::ULong _nelems) {
  return new seqSetRow[_nelems];
}

void seqSetRows::freebuf(seqSetRow *_data) {
  if (_data) delete[] _data;
}

seqSetRows::seqSetRows(CORBA::ULong _max) {
  _num_allocated = _max;
  _count = 0;
  if (_num_allocated > 0)
    _contents = allocbuf(_num_allocated);
  else
    _contents = (seqSetRow *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

seqSetRows::seqSetRows(
    CORBA::ULong _max,
    CORBA::ULong _len,
    seqSetRow *_data,
    CORBA::Boolean _release) {
  _num_allocated = _max;
  _count = _len;
  _contents = _data;
  _release_flag = _release;
  _ref_count = 1;
}

seqSetRows::seqSetRows(const seqSetRows& _seq) {
  _num_allocated = _seq._num_allocated;
  _count = _seq._count;
  if (_num_allocated > 0) {
    _contents = allocbuf(_num_allocated);
    for (CORBA::ULong i=0; i < _count; i++) {
      _contents[i] = _seq._contents[i];
    }
  }
  else
    _contents = (seqSetRow *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

seqSetRows::~seqSetRows() {
  if (_release_flag) freebuf(_contents);
}

seqSetRows& seqSetRows::operator=(const seqSetRows& _seq) {
  if (_count < _seq._count) {
    if (_num_allocated < _seq._count) {
      if (_release_flag)
        freebuf(_contents);
      else
        _release_flag = 1;
      _contents = allocbuf(_seq._num_allocated);
      _num_allocated = _seq._num_allocated;
    }
  }
  _count = _seq._count;
  for (CORBA::ULong i=0; i < _count; i++) {
    _contents[i] = _seq._contents[i];
  }
  return *this;
}

void seqSetRows::length(CORBA::ULong _newlen) {
  if (_newlen > _num_allocated) {
    seqSetRow *temp = allocbuf(_newlen);
    for (CORBA::ULong i=0; i < _count; i++) {
      temp[i] = _contents[i];
    }
    if (_release_flag)
      freebuf(_contents);
    else
      _release_flag = 1;
    _num_allocated = _newlen;
    _contents = temp;
  }
  _count = _newlen;
}

seqSetRow& seqSetRows::operator[](CORBA::ULong _index) {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

const seqSetRow& seqSetRows::operator[](CORBA::ULong _index) const {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

VISostream&  operator<<(VISostream& _strm, const seqSetRows& _seq) {
  _strm << _seq._count;
  for (CORBA::ULong i=0; i < _seq._count; i++) {
    _strm << _seq._contents[i];
  }
  return _strm;
}

VISistream& operator>>(VISistream& _strm,  seqSetRows& _seq) {
  CORBA::ULong t_count;
  _strm >> t_count;
  if (t_count > 0 && ! _strm.is_available(t_count)) {
    throw CORBA::MARSHAL();
  }
  if (t_count > _seq._count) {
    if (_seq._num_allocated < t_count) {
      if (_seq._release_flag)
        seqSetRows::freebuf(_seq._contents);
      else
        _seq._release_flag = 1;
      _seq._contents = seqSetRows::allocbuf(t_count);
      _seq._num_allocated = t_count;
    }
  }
  _seq._count = t_count;
  for (CORBA::ULong i=0; i < _seq._count; i++) {
    _strm >> _seq._contents[i];
  }
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const seqSetRows& _seq) {
  VISostream _ostrm(_strm);
  _ostrm << _seq;
  return _strm;
}


seqSetRows_ptr & seqSetRows_var::out() {
  seqSetRows::_release(_ptr);
  _ptr = (seqSetRows *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *RowSet::operator new(size_t ts) {
  return ::operator new(ts);
}

void RowSet::operator delete(void *p) {
  ::operator delete(p);
}


#endif

VISostream& operator<<(VISostream& _strm, const RowSet& _s) {
  _strm << _s.Header;
  _strm << _s.Rows;
  return _strm;
}

VISistream& operator>>(VISistream& _strm, RowSet& _s) {
  _strm >> _s.Header;
  _strm >> _s.Rows;
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const RowSet& _s) {
  VISostream _ostrm(_strm);
  _ostrm << _s;
  return _strm;
}


RowSet_ptr & RowSet_var::out() {
  if (_ptr != (RowSet *)NULL) delete _ptr;
  _ptr = (RowSet *)NULL;
  return _ptr;
}

Cartrige_ptr Cartrige_var:: _duplicate(Cartrige_ptr _p) { return Cartrige::_duplicate(_p); }
void Cartrige_var::_release(Cartrige_ptr _p) { CORBA::release(_p); }

Cartrige_var::Cartrige_var() : _ptr(Cartrige::_nil()) {}

Cartrige_var::Cartrige_var(Cartrige_ptr _p) : _ptr(_p) {}

Cartrige_var::Cartrige_var(const Cartrige_var& _var) :
   _ptr(Cartrige::_duplicate((Cartrige_ptr)_var)) {}

Cartrige_var::~Cartrige_var() { CORBA::release(_ptr); }

Cartrige_var& Cartrige_var::operator=(Cartrige_ptr _p) {
  CORBA::release(_ptr);
  _ptr = _p;
  return *this;
}


Cartrige_ptr& Cartrige_var::out() {
  CORBA::release(_ptr);
  _ptr = (Cartrige_ptr)NULL;
  return _ptr;
}

VISistream& operator>>(VISistream& _strm, Cartrige_var& _var) {
  _strm >> _var._ptr;
  return _strm;
}

VISostream& operator<<(VISostream& _strm, const Cartrige_var& _var) {
  _strm << _var._ptr;
  return _strm;
}

Istream& operator>>(Istream& _strm, Cartrige_var& _var) {
  VISistream _istrm(_strm);
  _istrm >> _var._ptr;
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const Cartrige_var& _var) {
  _strm << (CORBA::Object_ptr)_var._ptr;
  return _strm;
}

const CORBA::TypeInfo Cartrige::_class_info(
  "Cartrige",
  "IDL:Cartrige:1.0",
  NULL,
  &Cartrige::_factory,
  NULL, 0, 
  NULL, 0,
  CORBA::Object::_desc(),
  0);

VISistream& operator>>(VISistream& _strm, Cartrige_ptr& _obj) {
  CORBA::Object_var _var_obj(_obj);
  _var_obj = CORBA::Object::_read(_strm, Cartrige::_desc());
  _obj = Cartrige::_narrow(_var_obj);
  return _strm;
}

VISostream& operator<<(VISostream& _strm, const Cartrige_ptr _obj) {
  _strm << (CORBA_Object_ptr)_obj;
  return _strm;
}


const CORBA::TypeInfo *Cartrige::_desc() { return &_class_info; }

const CORBA::TypeInfo *Cartrige::_type_info() const { return &_class_info; }

void *Cartrige::_safe_narrow(const CORBA::TypeInfo& _info) const {
  if ( _info == _class_info) 
    return (void *)this;
  return CORBA_Object::_safe_narrow(_info);
}

CORBA::Object *Cartrige::_factory() {
  return new Cartrige;
}

Cartrige_ptr Cartrige::_this() {
  return Cartrige::_duplicate(___root);
}

Cartrige_ptr Cartrige::_narrow(CORBA::Object *_obj) {
  if ( _obj == CORBA::Object::_nil() )
    return Cartrige::_nil();
  else
    return Cartrige::_duplicate((Cartrige_ptr)_obj->_safe_narrow(_class_info));
}

Cartrige *Cartrige::_bind(
    const char *_object_name,
    const char *_host_name,
    const CORBA::BindOptions *_opt,
    CORBA::ORB_ptr _orb) {
  CORBA::Object_var _obj= CORBA::Object::_bind_to_object(
      "IDL:Cartrige:1.0", _object_name, _host_name, _opt, _orb);
  return Cartrige::_narrow(_obj);
}

char* Cartrige::Name() {
  char* _ret = (char*)0;
  CORBA::MarshalOutBuffer_var _obuf;
  CORBA::MarshalInBuffer_var _ibuf;
  
  while(1) {
    _obuf = ___root->_create_request(
        "_get_Name",
        1,
        843);
    try {
      _ibuf = ___root->_invoke(_obuf);
    }
    catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

void Cartrige::Name(const char* _val) {
  CORBA::MarshalOutBuffer_var _obuf;
  CORBA::MarshalInBuffer_var _ibuf;
  
  while(1) {
    _obuf = ___root->_create_request(
        "_set_Name",
        1,
        843);
    *(VISostream *)(CORBA::MarshalOutBuffer *)_obuf << _val;
    try {
      _ibuf = ___root->_invoke(_obuf);
    }
    catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
}

CORBA::Long Cartrige::OpenCursor(
    const char* _Query,
    const seqParams& _Parameters
    ) {

  CORBA::Long _ret = (CORBA::Long)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "OpenCursor",
        1,
        51904);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Query;
    _ostrm << _Parameters;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean Cartrige::CreateDataBaseObject(
    const seqOctets& _ObjDef
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "CreateDataBaseObject",
        1,
        55852150);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _ObjDef;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

RowSet* Cartrige::GetRowSet(
    const char* _Query,
    const seqParams& _Parameters
    ) {

  RowSet* _ret = (RowSet*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetRowSet",
        1,
        26234);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Query;
    _ostrm << _Parameters;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

void Cartrige::Disconnect(
    ) {

  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "Disconnect",
        1,
        51478);
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
}

CORBA::Boolean Cartrige::Connect(
    const seqParams& _InitValues
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "Connect",
        1,
        6550);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _InitValues;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean Cartrige::Connected() {
  CORBA::Boolean _ret;
  CORBA::MarshalOutBuffer_var _obuf;
  CORBA::MarshalInBuffer_var _ibuf;
  
  while(1) {
    _obuf = ___root->_create_request(
        "_get_Connected",
        1,
        26358);
    try {
      _ibuf = ___root->_invoke(_obuf);
    }
    catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

seqSetRow* Cartrige::GetCursorRow(
    CORBA::Long _Cursor
    ) {

  seqSetRow* _ret = (seqSetRow*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetCursorRow",
        1,
        207841);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Cursor;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

seqCartrigeParams* Cartrige::Parameters() {
  seqCartrigeParams* _ret = (seqCartrigeParams*)0;
  CORBA::MarshalOutBuffer_var _obuf;
  CORBA::MarshalInBuffer_var _ibuf;
  
  while(1) {
    _obuf = ___root->_create_request(
        "_get_Parameters",
        1,
        59667);
    try {
      _ibuf = ___root->_invoke(_obuf);
    }
    catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean Cartrige::NoMoreRows(
    CORBA::Long _Cursor
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "NoMoreRows",
        1,
        50657);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Cursor;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

void Cartrige::CloseCursor(
    CORBA::Long _Cursor
    ) {

  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "CloseCursor",
        1,
        103936);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Cursor;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
}

seqSetHeader* Cartrige::GetCursorHeared(
    CORBA::Long _Cursor
    ) {

  seqSetHeader* _ret = (seqSetHeader*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetCursorHeared",
        1,
        1662270);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Cursor;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

void Cartrige::Exec(
    const char* _Query,
    const seqParams& _Parameters
    ) {

  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "Exec",
        1,
        865);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Query;
    _ostrm << _Parameters;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
}


#if defined(MSVCNEWDLL_BUG)
void *Domain::operator new(size_t ts) {
  return ::operator new(ts);
}

void Domain::operator delete(void *p) {
  ::operator delete(p);
}


#endif

VISostream& operator<<(VISostream& _strm, const Domain& _s) {
  _strm << _s.Name;
  _strm << _s.CartrigeName;
  _strm << _s.SetupValues;
  return _strm;
}

VISistream& operator>>(VISistream& _strm, Domain& _s) {
  _strm >> _s.Name;
  _strm >> _s.CartrigeName;
  _strm >> _s.SetupValues;
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const Domain& _s) {
  VISostream _ostrm(_strm);
  _ostrm << _s;
  return _strm;
}


Domain_ptr & Domain_var::out() {
  if (_ptr != (Domain *)NULL) delete _ptr;
  _ptr = (Domain *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *ClientSideObjectDef::operator new(size_t ts) {
  return ::operator new(ts);
}

void ClientSideObjectDef::operator delete(void *p) {
  ::operator delete(p);
}


#endif

VISostream& operator<<(VISostream& _strm, const ClientSideObjectDef& _s) {
  _strm << _s.ObjBaseType;
  _strm << _s.ObjSubType;
  _strm << _s.Definition;
  return _strm;
}

VISistream& operator>>(VISistream& _strm, ClientSideObjectDef& _s) {
  _strm >> _s.ObjBaseType;
  _strm >> _s.ObjSubType;
  _strm >> _s.Definition;
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const ClientSideObjectDef& _s) {
  VISostream _ostrm(_strm);
  _ostrm << _s;
  return _strm;
}


ClientSideObjectDef_ptr & ClientSideObjectDef_var::out() {
  if (_ptr != (ClientSideObjectDef *)NULL) delete _ptr;
  _ptr = (ClientSideObjectDef *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *seqClientSideObjectDefs::operator new(size_t ts) {
  return ::operator new(ts);
}

void seqClientSideObjectDefs::operator delete(void *p) {
  ::operator delete(p);
}


#endif

ClientSideObjectDef* seqClientSideObjectDefs::allocbuf(CORBA::ULong _nelems) {
  return new ClientSideObjectDef[_nelems];
}

void seqClientSideObjectDefs::freebuf(ClientSideObjectDef *_data) {
  if (_data) delete[] _data;
}

seqClientSideObjectDefs::seqClientSideObjectDefs(CORBA::ULong _max) {
  _num_allocated = _max;
  _count = 0;
  if (_num_allocated > 0)
    _contents = allocbuf(_num_allocated);
  else
    _contents = (ClientSideObjectDef *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

seqClientSideObjectDefs::seqClientSideObjectDefs(
    CORBA::ULong _max,
    CORBA::ULong _len,
    ClientSideObjectDef *_data,
    CORBA::Boolean _release) {
  _num_allocated = _max;
  _count = _len;
  _contents = _data;
  _release_flag = _release;
  _ref_count = 1;
}

seqClientSideObjectDefs::seqClientSideObjectDefs(const seqClientSideObjectDefs& _seq) {
  _num_allocated = _seq._num_allocated;
  _count = _seq._count;
  if (_num_allocated > 0) {
    _contents = allocbuf(_num_allocated);
    for (CORBA::ULong i=0; i < _count; i++) {
      _contents[i] = _seq._contents[i];
    }
  }
  else
    _contents = (ClientSideObjectDef *)NULL;
  _release_flag = 1;
  _ref_count = 1;
}

seqClientSideObjectDefs::~seqClientSideObjectDefs() {
  if (_release_flag) freebuf(_contents);
}

seqClientSideObjectDefs& seqClientSideObjectDefs::operator=(const seqClientSideObjectDefs& _seq) {
  if (_count < _seq._count) {
    if (_num_allocated < _seq._count) {
      if (_release_flag)
        freebuf(_contents);
      else
        _release_flag = 1;
      _contents = allocbuf(_seq._num_allocated);
      _num_allocated = _seq._num_allocated;
    }
  }
  _count = _seq._count;
  for (CORBA::ULong i=0; i < _count; i++) {
    _contents[i] = _seq._contents[i];
  }
  return *this;
}

void seqClientSideObjectDefs::length(CORBA::ULong _newlen) {
  if (_newlen > _num_allocated) {
    ClientSideObjectDef *temp = allocbuf(_newlen);
    for (CORBA::ULong i=0; i < _count; i++) {
      temp[i] = _contents[i];
    }
    if (_release_flag)
      freebuf(_contents);
    else
      _release_flag = 1;
    _num_allocated = _newlen;
    _contents = temp;
  }
  _count = _newlen;
}

ClientSideObjectDef& seqClientSideObjectDefs::operator[](CORBA::ULong _index) {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

const ClientSideObjectDef& seqClientSideObjectDefs::operator[](CORBA::ULong _index) const {
  if (_index >= _count)
    throw CORBA::BAD_PARAM();
  return _contents[_index];
}

VISostream&  operator<<(VISostream& _strm, const seqClientSideObjectDefs& _seq) {
  _strm << _seq._count;
  for (CORBA::ULong i=0; i < _seq._count; i++) {
    _strm << _seq._contents[i];
  }
  return _strm;
}

VISistream& operator>>(VISistream& _strm,  seqClientSideObjectDefs& _seq) {
  CORBA::ULong t_count;
  _strm >> t_count;
  if (t_count > 0 && ! _strm.is_available(t_count)) {
    throw CORBA::MARSHAL();
  }
  if (t_count > _seq._count) {
    if (_seq._num_allocated < t_count) {
      if (_seq._release_flag)
        seqClientSideObjectDefs::freebuf(_seq._contents);
      else
        _seq._release_flag = 1;
      _seq._contents = seqClientSideObjectDefs::allocbuf(t_count);
      _seq._num_allocated = t_count;
    }
  }
  _seq._count = t_count;
  for (CORBA::ULong i=0; i < _seq._count; i++) {
    _strm >> _seq._contents[i];
  }
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const seqClientSideObjectDefs& _seq) {
  VISostream _ostrm(_strm);
  _ostrm << _seq;
  return _strm;
}


seqClientSideObjectDefs_ptr & seqClientSideObjectDefs_var::out() {
  seqClientSideObjectDefs::_release(_ptr);
  _ptr = (seqClientSideObjectDefs *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *Platform::operator new(size_t ts) {
  return ::operator new(ts);
}

void Platform::operator delete(void *p) {
  ::operator delete(p);
}


#endif

VISostream& operator<<(VISostream& _strm, const Platform& _s) {
  _strm << _s.Name;
  _strm << _s.ClientSideObjectDefs;
  return _strm;
}

VISistream& operator>>(VISistream& _strm, Platform& _s) {
  _strm >> _s.Name;
  _strm >> _s.ClientSideObjectDefs;
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const Platform& _s) {
  VISostream _ostrm(_strm);
  _ostrm << _s;
  return _strm;
}


Platform_ptr & Platform_var::out() {
  if (_ptr != (Platform *)NULL) delete _ptr;
  _ptr = (Platform *)NULL;
  return _ptr;
}

AppServer_ptr AppServer_var:: _duplicate(AppServer_ptr _p) { return AppServer::_duplicate(_p); }
void AppServer_var::_release(AppServer_ptr _p) { CORBA::release(_p); }

AppServer_var::AppServer_var() : _ptr(AppServer::_nil()) {}

AppServer_var::AppServer_var(AppServer_ptr _p) : _ptr(_p) {}

AppServer_var::AppServer_var(const AppServer_var& _var) :
   _ptr(AppServer::_duplicate((AppServer_ptr)_var)) {}

AppServer_var::~AppServer_var() { CORBA::release(_ptr); }

AppServer_var& AppServer_var::operator=(AppServer_ptr _p) {
  CORBA::release(_ptr);
  _ptr = _p;
  return *this;
}


AppServer_ptr& AppServer_var::out() {
  CORBA::release(_ptr);
  _ptr = (AppServer_ptr)NULL;
  return _ptr;
}

VISistream& operator>>(VISistream& _strm, AppServer_var& _var) {
  _strm >> _var._ptr;
  return _strm;
}

VISostream& operator<<(VISostream& _strm, const AppServer_var& _var) {
  _strm << _var._ptr;
  return _strm;
}

Istream& operator>>(Istream& _strm, AppServer_var& _var) {
  VISistream _istrm(_strm);
  _istrm >> _var._ptr;
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const AppServer_var& _var) {
  _strm << (CORBA::Object_ptr)_var._ptr;
  return _strm;
}

const CORBA::TypeInfo AppServer::_class_info(
  "AppServer",
  "IDL:AppServer:1.0",
  NULL,
  &AppServer::_factory,
  NULL, 0, 
  NULL, 0,
  CORBA::Object::_desc(),
  0);

VISistream& operator>>(VISistream& _strm, AppServer_ptr& _obj) {
  CORBA::Object_var _var_obj(_obj);
  _var_obj = CORBA::Object::_read(_strm, AppServer::_desc());
  _obj = AppServer::_narrow(_var_obj);
  return _strm;
}

VISostream& operator<<(VISostream& _strm, const AppServer_ptr _obj) {
  _strm << (CORBA_Object_ptr)_obj;
  return _strm;
}


const CORBA::TypeInfo *AppServer::_desc() { return &_class_info; }

const CORBA::TypeInfo *AppServer::_type_info() const { return &_class_info; }

void *AppServer::_safe_narrow(const CORBA::TypeInfo& _info) const {
  if ( _info == _class_info) 
    return (void *)this;
  return CORBA_Object::_safe_narrow(_info);
}

CORBA::Object *AppServer::_factory() {
  return new AppServer;
}

AppServer_ptr AppServer::_this() {
  return AppServer::_duplicate(___root);
}

AppServer_ptr AppServer::_narrow(CORBA::Object *_obj) {
  if ( _obj == CORBA::Object::_nil() )
    return AppServer::_nil();
  else
    return AppServer::_duplicate((AppServer_ptr)_obj->_safe_narrow(_class_info));
}

AppServer *AppServer::_bind(
    const char *_object_name,
    const char *_host_name,
    const CORBA::BindOptions *_opt,
    CORBA::ORB_ptr _orb) {
  CORBA::Object_var _obj= CORBA::Object::_bind_to_object(
      "IDL:AppServer:1.0", _object_name, _host_name, _opt, _orb);
  return AppServer::_narrow(_obj);
}

sList* AppServer::GetSystemDomains(
    const char* _SystemName
    ) {

  sList* _ret = (sList*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetSystemDomains",
        1,
        3397555);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _SystemName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

void AppServer::Logoff(
    ) {

  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "Logoff",
        1,
        3422);
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
}

char* AppServer::CurrentSystem() {
  char* _ret = (char*)0;
  CORBA::MarshalOutBuffer_var _obuf;
  CORBA::MarshalInBuffer_var _ibuf;
  
  while(1) {
    _obuf = ___root->_create_request(
        "_get_CurrentSystem",
        1,
        455711);
    try {
      _ibuf = ___root->_invoke(_obuf);
    }
    catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

seqOctets* AppServer::GetClientSideObject(
    const char* _PlatformName,
    BaseType _ObjBaseType,
    const char* _ObjSubType
    ) {

  seqOctets* _ret = (seqOctets*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetClientSideObject",
        1,
        26327542);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _PlatformName;
    _ostrm << _ObjBaseType;
    _ostrm << _ObjSubType;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

Cartrige_ptr AppServer::GetDomainCartrige(
    const char* _Domain
    ) {

  Cartrige_ptr _ret = (Cartrige_ptr)NULL;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetDomainCartrige",
        1,
        6591071);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Domain;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServer::Logon(
    const char* _Name,
    const char* _Pass
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "Logon",
        1,
        1684);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Name;
    _ostrm << _Pass;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

void AppServer::ChooseBuild(
    const char* _SystemName,
    const char* _BuildName
    ) {

  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "ChooseBuild",
        1,
        103024);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _SystemName;
    _ostrm << _BuildName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
}

CORBA::Boolean AppServer::Connected() {
  CORBA::Boolean _ret;
  CORBA::MarshalOutBuffer_var _obuf;
  CORBA::MarshalInBuffer_var _ibuf;
  
  while(1) {
    _obuf = ___root->_create_request(
        "_get_Connected",
        1,
        26358);
    try {
      _ibuf = ___root->_invoke(_obuf);
    }
    catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

seqTwiceStrings* AppServer::GetBuids(
    ) {

  seqTwiceStrings* _ret = (seqTwiceStrings*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetBuids",
        1,
        13015);
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

seqOctets* AppServer::GetObject(
    BaseType _ObjBaseType,
    const char* _ObjSubType,
    const char* _ObjectName
    ) {

  seqOctets* _ret = (seqOctets*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetObject",
        1,
        25910);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _ObjBaseType;
    _ostrm << _ObjSubType;
    _ostrm << _ObjectName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

void AppServer::ChangePassword(
    const char* _NewPassword
    ) {

  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "ChangePassword",
        1,
        835732);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _NewPassword;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
}

seqOctets* AppServer::GetTask(
    const char* _Task
    ) {

  seqOctets* _ret = (seqOctets*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetTask",
        1,
        6537);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Task;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

char* AppServer::CurrentBuild() {
  char* _ret = (char*)0;
  CORBA::MarshalOutBuffer_var _obuf;
  CORBA::MarshalInBuffer_var _ibuf;
  
  while(1) {
    _obuf = ___root->_create_request(
        "_get_CurrentBuild",
        1,
        228112);
    try {
      _ibuf = ___root->_invoke(_obuf);
    }
    catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}


#if defined(MSVCNEWDLL_BUG)
void *BuildRight::operator new(size_t ts) {
  return ::operator new(ts);
}

void BuildRight::operator delete(void *p) {
  ::operator delete(p);
}


#endif

VISostream& operator<<(VISostream& _strm, const BuildRight& _s) {
  _strm << _s.BuildName;
  _strm << _s.SystemName;
  _strm << _s.GroupOrUser;
  _strm << _s.IsUser;
  _strm << _s.AllowAccess;
  return _strm;
}

VISistream& operator>>(VISistream& _strm, BuildRight& _s) {
  _strm >> _s.BuildName;
  _strm >> _s.SystemName;
  _strm >> _s.GroupOrUser;
  _strm >> _s.IsUser;
  _strm >> _s.AllowAccess;
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const BuildRight& _s) {
  VISostream _ostrm(_strm);
  _ostrm << _s;
  return _strm;
}


BuildRight_ptr & BuildRight_var::out() {
  if (_ptr != (BuildRight *)NULL) delete _ptr;
  _ptr = (BuildRight *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *TaskRight::operator new(size_t ts) {
  return ::operator new(ts);
}

void TaskRight::operator delete(void *p) {
  ::operator delete(p);
}


#endif

VISostream& operator<<(VISostream& _strm, const TaskRight& _s) {
  _strm << _s.BuildName;
  _strm << _s.SystemName;
  _strm << _s.TaskName;
  _strm << _s.GroupOrUser;
  _strm << _s.IsUser;
  _strm << _s.AllowExec;
  return _strm;
}

VISistream& operator>>(VISistream& _strm, TaskRight& _s) {
  _strm >> _s.BuildName;
  _strm >> _s.SystemName;
  _strm >> _s.TaskName;
  _strm >> _s.GroupOrUser;
  _strm >> _s.IsUser;
  _strm >> _s.AllowExec;
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const TaskRight& _s) {
  VISostream _ostrm(_strm);
  _ostrm << _s;
  return _strm;
}


TaskRight_ptr & TaskRight_var::out() {
  if (_ptr != (TaskRight *)NULL) delete _ptr;
  _ptr = (TaskRight *)NULL;
  return _ptr;
}


#if defined(MSVCNEWDLL_BUG)
void *ObjectRight::operator new(size_t ts) {
  return ::operator new(ts);
}

void ObjectRight::operator delete(void *p) {
  ::operator delete(p);
}


#endif

VISostream& operator<<(VISostream& _strm, const ObjectRight& _s) {
  _strm << _s.BuildName;
  _strm << _s.SystemName;
  _strm << _s.ObjectName;
  _strm << _s.GroupOrUser;
  _strm << _s.IsUser;
  _strm << _s.AllowExec;
  _strm << _s.AllowRead;
  _strm << _s.AllowWrite;
  return _strm;
}

VISistream& operator>>(VISistream& _strm, ObjectRight& _s) {
  _strm >> _s.BuildName;
  _strm >> _s.SystemName;
  _strm >> _s.ObjectName;
  _strm >> _s.GroupOrUser;
  _strm >> _s.IsUser;
  _strm >> _s.AllowExec;
  _strm >> _s.AllowRead;
  _strm >> _s.AllowWrite;
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const ObjectRight& _s) {
  VISostream _ostrm(_strm);
  _ostrm << _s;
  return _strm;
}


ObjectRight_ptr & ObjectRight_var::out() {
  if (_ptr != (ObjectRight *)NULL) delete _ptr;
  _ptr = (ObjectRight *)NULL;
  return _ptr;
}

AppServerStorageManager_ptr AppServerStorageManager_var:: _duplicate(AppServerStorageManager_ptr _p) { return AppServerStorageManager::_duplicate(_p); }
void AppServerStorageManager_var::_release(AppServerStorageManager_ptr _p) { CORBA::release(_p); }

AppServerStorageManager_var::AppServerStorageManager_var() : _ptr(AppServerStorageManager::_nil()) {}

AppServerStorageManager_var::AppServerStorageManager_var(AppServerStorageManager_ptr _p) : _ptr(_p) {}

AppServerStorageManager_var::AppServerStorageManager_var(const AppServerStorageManager_var& _var) :
   _ptr(AppServerStorageManager::_duplicate((AppServerStorageManager_ptr)_var)) {}

AppServerStorageManager_var::~AppServerStorageManager_var() { CORBA::release(_ptr); }

AppServerStorageManager_var& AppServerStorageManager_var::operator=(AppServerStorageManager_ptr _p) {
  CORBA::release(_ptr);
  _ptr = _p;
  return *this;
}


AppServerStorageManager_ptr& AppServerStorageManager_var::out() {
  CORBA::release(_ptr);
  _ptr = (AppServerStorageManager_ptr)NULL;
  return _ptr;
}

VISistream& operator>>(VISistream& _strm, AppServerStorageManager_var& _var) {
  _strm >> _var._ptr;
  return _strm;
}

VISostream& operator<<(VISostream& _strm, const AppServerStorageManager_var& _var) {
  _strm << _var._ptr;
  return _strm;
}

Istream& operator>>(Istream& _strm, AppServerStorageManager_var& _var) {
  VISistream _istrm(_strm);
  _istrm >> _var._ptr;
  return _strm;
}

Ostream& operator<<(Ostream& _strm, const AppServerStorageManager_var& _var) {
  _strm << (CORBA::Object_ptr)_var._ptr;
  return _strm;
}

const CORBA::TypeInfo AppServerStorageManager::_class_info(
  "AppServerStorageManager",
  "IDL:AppServerStorageManager:1.0",
  NULL,
  &AppServerStorageManager::_factory,
  NULL, 0, 
  NULL, 0,
  AppServer::_desc(),
  0);

VISistream& operator>>(VISistream& _strm, AppServerStorageManager_ptr& _obj) {
  CORBA::Object_var _var_obj(_obj);
  _var_obj = CORBA::Object::_read(_strm, AppServerStorageManager::_desc());
  _obj = AppServerStorageManager::_narrow(_var_obj);
  return _strm;
}

VISostream& operator<<(VISostream& _strm, const AppServerStorageManager_ptr _obj) {
  _strm << (CORBA_Object_ptr)_obj;
  return _strm;
}


const CORBA::TypeInfo *AppServerStorageManager::_desc() { return &_class_info; }

const CORBA::TypeInfo *AppServerStorageManager::_type_info() const { return &_class_info; }

void *AppServerStorageManager::_safe_narrow(const CORBA::TypeInfo& _info) const {
  if ( _info == _class_info) 
    return (void *)this;
  if ( _info == *AppServer::_desc() )
    return (void *)(AppServer *)this;
  return CORBA_Object::_safe_narrow(_info);
}

CORBA::Object *AppServerStorageManager::_factory() {
  return new AppServerStorageManager;
}

AppServerStorageManager_ptr AppServerStorageManager::_this() {
  return AppServerStorageManager::_duplicate(___root);
}

AppServerStorageManager_ptr AppServerStorageManager::_narrow(CORBA::Object *_obj) {
  if ( _obj == CORBA::Object::_nil() )
    return AppServerStorageManager::_nil();
  else
    return AppServerStorageManager::_duplicate((AppServerStorageManager_ptr)_obj->_safe_narrow(_class_info));
}

AppServerStorageManager *AppServerStorageManager::_bind(
    const char *_object_name,
    const char *_host_name,
    const CORBA::BindOptions *_opt,
    CORBA::ORB_ptr _orb) {
  CORBA::Object_var _obj= CORBA::Object::_bind_to_object(
      "IDL:AppServerStorageManager:1.0", _object_name, _host_name, _opt, _orb);
  return AppServerStorageManager::_narrow(_obj);
}

sList* AppServerStorageManager::GetPlatforms(
    ) {

  sList* _ret = (sList*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetPlatforms",
        1,
        209081);
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::DelGroup(
    const char* _GroupName
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "DelGroup",
        1,
        12294);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _GroupName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::AddGroup(
    const char* _GroupName
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "AddGroup",
        1,
        13254);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _GroupName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::DelSystemTask(
    const char* _SystemName,
    const char* _TaskName
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "DelSystemTask",
        1,
        404057);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _SystemName;
    _ostrm << _TaskName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::AddSystem(
    const char* _SystemName
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "AddSystem",
        1,
        25887);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _SystemName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::GetBuildRight(
    BuildRight& _Right
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetBuildRight",
        1,
        417104);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Right;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  _vistrm >> _Right;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::AddSystemObject(
    const char* _SystemName,
    const char* _ObjectName,
    BaseType _ObjectBaseType
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "AddSystemObject",
        1,
        1657462);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _SystemName;
    _ostrm << _ObjectName;
    _ostrm << _ObjectBaseType;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

sList* AppServerStorageManager::GetGroupUsers(
    const char* _GroupName
    ) {

  sList* _ret = (sList*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetGroupUsers",
        1,
        415499);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _GroupName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::DelSystemBuildDomain(
    const char* _SystemName,
    const char* _BuildName,
    const char* _DomainName
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "DelSystemBuildDomain",
        1,
        51728416);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _SystemName;
    _ostrm << _BuildName;
    _ostrm << _DomainName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::AddSystemBuild(
    const char* _SystemName,
    const char* _BuildName
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "AddSystemBuild",
        1,
        828784);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _SystemName;
    _ostrm << _BuildName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::DelUserFromGroup(
    const char* _GroupName,
    const char* _UserName
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "DelUserFromGroup",
        1,
        3217318);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _GroupName;
    _ostrm << _UserName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::DelSystemObject(
    const char* _SystemName,
    const char* _ObjectName,
    BaseType _ObjectBaseType
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "DelSystemObject",
        1,
        1616502);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _SystemName;
    _ostrm << _ObjectName;
    _ostrm << _ObjectBaseType;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::DelSystemBuild(
    const char* _SystemName,
    const char* _BuildName
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "DelSystemBuild",
        1,
        808304);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _SystemName;
    _ostrm << _BuildName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

sList* AppServerStorageManager::GetSubTypes(
    BaseType _ObjBaseType
    ) {

  sList* _ret = (sList*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetSubTypes",
        1,
        105841);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _ObjBaseType;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

sList* AppServerStorageManager::GetGroups(
    ) {

  sList* _ret = (sList*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetGroups",
        1,
        25983);
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::AddUserToGroup(
    const char* _GroupName,
    const char* _UserName
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "AddUserToGroup",
        1,
        831526);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _GroupName;
    _ostrm << _UserName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::SetupSystemObject(
    const char* _SystemName,
    const char* _ObjectName,
    const char* _ObjectBaseType,
    const char* _ObjectSubType,
    const seqOctets& _Octets
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "SetupSystemObject",
        1,
        7793270);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _SystemName;
    _ostrm << _ObjectName;
    _ostrm << _ObjectBaseType;
    _ostrm << _ObjectSubType;
    _ostrm << _Octets;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::AddClientObject(
    const char* _PlatformName,
    BaseType _ObjBaseType,
    const char* _ObjSubType,
    const seqOctets& _Octets
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "AddClientObject",
        1,
        1685686);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _PlatformName;
    _ostrm << _ObjBaseType;
    _ostrm << _ObjSubType;
    _ostrm << _Octets;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::AddPlatform(
    const char* _Name
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "AddPlatform",
        1,
        103013);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Name;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::SetupSystemTask(
    const char* _SystemName,
    const char* _TaskName,
    const seqOctets& _Octets
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "SetupSystemTask",
        1,
        1948249);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _SystemName;
    _ostrm << _TaskName;
    _ostrm << _Octets;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::GetTaskRight(
    TaskRight& _Right
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetTaskRight",
        1,
        210544);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Right;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  _vistrm >> _Right;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::GetObjectRight(
    ObjectRight& _Right
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetObjectRight",
        1,
        827792);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Right;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  _vistrm >> _Right;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::DelSystem(
    const char* _SystemName
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "DelSystem",
        1,
        25247);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _SystemName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::DelUser(
    const char* _UserName
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "DelUser",
        1,
        6332);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _UserName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::DelClientObject(
    const char* _PlatformName,
    BaseType _ObjBaseType,
    const char* _ObjSubType
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "DelClientObject",
        1,
        1595574);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _PlatformName;
    _ostrm << _ObjBaseType;
    _ostrm << _ObjSubType;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::SetObjectRight(
    const ObjectRight& _Right
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "SetObjectRight",
        1,
        926096);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Right;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::AddSystemBuildDomain(
    const char* _SystemName,
    const char* _BuildName,
    const char* _DomainName,
    const char* _CartrigeName
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "AddSystemBuildDomain",
        1,
        53039136);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _SystemName;
    _ostrm << _BuildName;
    _ostrm << _DomainName;
    _ostrm << _CartrigeName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::SetBuildRight(
    const BuildRight& _Right
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "SetBuildRight",
        1,
        466256);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Right;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::AddSystemTask(
    const char* _SystemName,
    const char* _TaskName
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "AddSystemTask",
        1,
        414297);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _SystemName;
    _ostrm << _TaskName;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::SetupSystemBuildDomain(
    const char* _SystemName,
    const char* _BuildName,
    const char* _DomainName,
    const seqParams& _SetupValues
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "SetupSystemBuildDomain",
        1,
        249384992);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _SystemName;
    _ostrm << _BuildName;
    _ostrm << _DomainName;
    _ostrm << _SetupValues;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

sList* AppServerStorageManager::GetUsers(
    ) {

  sList* _ret = (sList*)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "GetUsers",
        1,
        13195);
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::SetTaskRight(
    const TaskRight& _Right
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "SetTaskRight",
        1,
        235120);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _Right;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

CORBA::Boolean AppServerStorageManager::AddUser(
    const char* _UserName,
    const char* _Password,
    CORBA::Boolean _IsAdmin
    ) {

  CORBA::Boolean _ret = (CORBA::Boolean)0;
  CORBA_MarshalInBuffer_var _ibuf;
  CORBA::MarshalOutBuffer_var _obuf;
  
  while( 1 ) { 
    _obuf = ___root->_create_request(
        "AddUser",
        1,
        6492);
    VISostream& _ostrm = *(VISostream *)(CORBA::MarshalOutBuffer*)_obuf;
    _ostrm << _UserName;
    _ostrm << _Password;
    _ostrm << _IsAdmin;
    
    
    try { 
      _ibuf = ___root->_invoke(_obuf);
    } catch (const CORBA::TRANSIENT& ) {
      continue;
    }
    break;
  }
  VISistream& _vistrm = *(CORBA::MarshalInBuffer *)_ibuf;
  _vistrm >> _ret;
  return _ret;
}

